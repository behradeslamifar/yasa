#!/bin/bash 

# development state
develop=0

# enable administrative log. 1: enabel, 0: disable
ADMIN_LOG=1

# Home
YASAHOME='/etc/yasa'

# Group Home
GRPHOME='/etc/yasa/group'

# default file
TEMPHOME='/etc/yasa/skell'

# puppet home (ln -s /etc/yasa/puppet /etc/puppet/modules/yasa)
PUPPETHOME='/etc/yasa/puppet'

# white list files
WDEVICE='dev.allow'
WCLASS='class.allow'
WDEF='default'

# default policy (class, deauthorized)
#DEFPOL='default'

# clients home
# $CLIENTHOME/$fqdn/
CLIENTHOME='/etc/yasa/puppet/files/hosts'

# udev config filename
UDEVCONF="10-usblock.rules"

# device log file
DEVICELOG="/var/log/usblock.log"

# require fuctions that help simple programing
# host_exist
#
# This script need use global variable structure

group_modify_class() { 
	# temp file for dialog output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local groupid=$1
	local classid

	# choose between usb class
        /usr/bin/dialog --backtitle "Usb lock main menu" \
        --title "[ List of USB Class ]" \
        --checklist "Choose a class to add to whitelist" 13 60 22 \
	00h "Use class information in the Interface Descriptors" off \
	01h "Audio" off \
	02h "Communications and CDC Control" off \
	03h "HID (Human Interface Device)" on \
	05h "Physical" off \
	06h "Image" off \
	07h "Printer" off \
	08h "Mass Storage" off \
	09h "Hub" on \
	0Ah "CDC-Data" off \
	0Bh "Smart Card" off \
	0Dh "Content Security" off \
	0Eh "Video" off \
	0Fh "Personal Healthcare" off \
	10h "Audio/Video Devices" off \
	11h "Billboard Device Class" off \
	12h "USB Type-C Bridge Class" off \
	DCh "Diagnostic Device" off \
	E0h "Wireless Controller" off \
	EFh "Miscellaneous" off \
	FEh "Application Specific" off \
	FFh "Vendor Specific" off 2> $OUTPUT

	# save dialog state (find if user press cancel)
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$OUTPUT" ] && rm $OUTPUT
	
		return 1
	fi

	# start with fresh class file
	echo "" > $GRPHOME/$groupid/class.allow

	for classid in $(<$OUTPUT)
	do
		classid=$(echo $classid | tr -d 'h')
		echo $classid >> $GRPHOME/$groupid/class.allow 	
	done

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0

}

group_device_existence_check() {
	local groupid="$1"
        local vendorid="$2"
        local productid="$3"
        local serial="$4"

	# return 1 if device not added 
	[ -z $(grep ".*$vendorid.*$productid.*$serial.*" $GRPHOME/$groupid/$WDEVICE | cut -f 1 -d " ") ] && return 1

	# return 0 if device already exist 
	return 0


}

group_modify_dev() {
	# local variables
	local validtime=0
	local currenttime
	local groupid=$1
	local keyword
	local response
	local log_line_number

	# define local array
	local log_line_array=()
	local log_line=()

	# temperorly file 
	local INPUT1=$(mktemp /tmp/usb.XXXXXXXX)
	local INPUT2=$(mktemp /tmp/usb.XXXXXXXX)
	
	# menu output
	local OUTPUT=$(mktemp /tmp/output.XXXXXXX)

	# trap and delete temp file
	trap "rm $INPUT1 $INPUT2 $OUTPUT; exit" SIGHUP SIGINT SIGTERM
	
	while true
	do
	    # search based on ip address
	    dialog --inputbox "Please search the keywork to find your device (ip|hostname|device)" 8 80 2> $OUTPUT

	    # save dialog state (find if user press cancel)
	    response=$?

	    # save input variable
	    keyword=$(<$OUTPUT)

	    # if user cancel the dialog or press escape 
	    if [ "$response" == "1" -o "$response" == "255" ]
	    then
	    	[ -f "$INPUT1" ] && rm $INPUT1
	    	[ -f "$INPUT2" ] && rm $INPUT2
	    	[ -f "$OUTPUT" ] && rm $OUTPUT
	    
	    	return 1
	    fi

	    # normalize log file
	    cat $DEVICELOG | grep -i "$keyword" | tail | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' > "$INPUT2"

	    if [ ! -z "$(<$INPUT2)" ]
	    then
		break
	    fi
	done

	cat "$INPUT2" | cut -f 1,3,5,6,7,8 -d " " > "$INPUT1"

	while read n s ; do
	    log_line_array+=($n "$s")
	done < $INPUT1

	dialog  --title "Founded devices" --menu "Your choozen device will be add to whitelist" 0 80 5 "${log_line_array[@]}" 2> $OUTPUT

	# get reponse
	response=$?

	# get data stored in $OUTPUT
	log_line_number=$(<$OUTPUT)
	
	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 1
	fi

	# pick log line
	log_line=($(sed -n "$log_line_number p" $INPUT1))

	# check if device added befor
	group_device_existence_check ${log_line[1]#*:} ${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:} && dialog --msgbox "Device already exist in whitelist" 5 38 && return 1

	# input comment
	dialog --inputbox "Write comment for this device" 8 80 "no comment" 2> $OUTPUT
	local comment=$(<$OUTPUT)

	# get response
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 1
	fi

	# input box for enter validation time in houre
	while true
	do
		dialog --inputbox "Please enter validation time in houre (enter 0 or leave blank for unlimite time)" 8 80 0 2> $OUTPUT
		validtime=$(<$OUTPUT)

		# get response
		response=$?

		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp files
			[ -f "$INPUT1" ] && rm $INPUT1
			[ -f "$INPUT2" ] && rm $INPUT2
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 1
		fi

		if [ "$validtime" = "0" ]
		then
			break
		elif [ ! -z "$(echo $validtime | grep '^[1-9][0-9]*$')" ]
		then
			currenttime=$(date +"%s")
			validtime=$(( $validtime * 60 * 60 + $currenttime ))
			break
		fi
	done


	# add new device to white list
	echo -e "# comment $comment \n# ${log_line[1]} ${log_line[2] } \n${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:}\n" >> $GRPHOME/$groupid/$WDEVICE
		
	# remove temp file if exist
	[ -f "$INPUT1" ] && rm $INPUT1
	[ -f "$INPUT2" ] && rm $INPUT2
	[ -f "$OUTPUT" ] && rm $OUTPUT
	
	return 0
}

group_udev_gen() {
    # temperorly file 
    TEMP=$(mktemp /tmp/usb.XXXXXXXX)
    
    # trap and delete temp file
    trap "rm $TEMP; exit" SIGHUP SIGINT SIGTERM
    
    local groupid="$1"
    local grouppath="$GRPHOME/$groupid"

	echo "" > "$grouppath/25-default-whitelist"
	cat "$grouppath/$WCLASS" | grep -v "^#\|^$" | while read line; do
                echo "ATTR{bInterfaceClass}==\"$line\", ENV{valid}=\"2\""  >> "$grouppath/25-default-whitelist"
	done
	
	echo "" > "$grouppath/20-whitelist"
        cat "$grouppath/$WDEVICE" | grep -v "^#\|^$" > $TEMP
	
	while read validtime vid pid serial 
	do
	        if [ -z "$serial" -a -z "$pid" ]
		then
	                echo "ATTR{idVendor}==\"$vid\", ENV{valid}=\"1\""  >> "$grouppath/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ENV{valid}=\"2\""  >> "$grouppath/20-whitelist"
		elif [ -z "$serial" ]
		then
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ENV{valid}=\"1\""  >> "$grouppath/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ENV{valid}=\"2\""  >> "$grouppath/20-whitelist"
	        else
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ATTR{serial}==\"$serial\", ENV{valid}=\"1\"" >> "$grouppath/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ATTRS{serial}==\"$serial\", ENV{valid}=\"2\"" >> "$grouppath/20-whitelist"
	        fi
	done < $TEMP
	
	for I in $grouppath/[0-9]*
	do
		if [ ! -z "$(echo $I | grep '10-header$')" ]
		then
			cat $I > "$grouppath/etc/10-usblock.rules"
		else 
			cat $I >> "$grouppath/etc/10-usblock.rules"
		fi
	done

	#remove temp file
	[ -f "$TEMP" ] && rm $TEMP

	return 0

}


group_modify_rule() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM


        # count number of host
        local groupsum=$(ls $GRPHOME | wc -l)

	if [ -z "$1" ]
	then
		local interactive=1
	else
		local interactive=0
		local groupid=$1
	fi

	while true
	do
	   if [ "$interactive" == "1" ]
	   then
		# choose group to modify
		dialog --title "Group List" --menu "Choose one group to modify" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $OUTPUT
	
		# get response
		response=$?

		# save dialog output in variable
		local groupid=$(<$OUTPUT)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
			
			return 1
		fi
	
	   fi
	   
	   # modify class
	   group_modify_class $groupid

	   # if press cancel remove group folder
	   response=$?

	   if [ "$response" == "1" ]
	   then
	   	[ -f "$OUTPUT" ] && rm $OUTPUT
	   	return 1
	   fi

	   # Modify device whitelist
	   while true
	   do
	   	# modify device that allow in group
	   	group_modify_dev $groupid

	   	# if press cancel remove group folder
	   	response=$?

	   	if [ "$response" == "1" ]
	   	then
	   		break
	   	fi
		
		# add another device
		dialog --backtitle "Group Management" --title " Another Device " --yesno "Do you add another device to whitelist?" 6 50
		
		# get response
		response=$?

		if [ "$response" == "0" ]
		then
			continue
		else
			break
		fi
	   done

	   # create udev rule
	   group_udev_gen $groupid

	   # if press cancel remove group folder
	   response=$?

	   if [ "$response" == "1" ]
	   then
	   	[ -f "$OUTPUT" ] && rm $OUTPUT
	   	return 1
	   fi

	   # break while if noninteractive
           if [ "$interactive" == "0" ]
           then
		break
	   fi
 
	done

        # remove temp file
        [ -f "$OUTPUT" ] && rm $OUTPUT

        return 0

}

group_find_member() {
	# define local variable
	local groupid="$1"
	local hostid="$2"

	group_member=$(ls $CLIENTHOME/$hostid/temp/grp.* 2>/dev/null | grep "\<$groupid\>")
	if [ ! -z "$group_member" ]
	then 
		echo "on"
	else
		echo "off"
	fi

	return 0
}

host_write_rule() { 
    # temperorly file 
    TEMP=$(mktemp /tmp/usb.XXXXXXXX)
    
    # trap and delete temp file
    trap "rm $TEMP; exit" SIGHUP SIGINT SIGTERM
    
    local hostid="$1"
    local hostpath="$CLIENTHOME/$hostid"
    local groupid

    if [ -e $hostpath/temp/grp.* ]
    then
	groupid=$(ls $hostpath/temp/grp.*)
	groupid=${groupid##*.}
	cp $GRPHOME/$groupid/etc/10-usblock.rules $CLIENTHOME/$hostid/etc/
    
    else
	echo "" > "$hostpath/temp/25-default-whitelist"
	cat "$hostpath/temp/$WCLASS" | grep -v "^#\|^$" | while read line; do
                echo "ATTR{bInterfaceClass}==\"$line\", ENV{valid}=\"2\""  >> "$hostpath/temp/25-default-whitelist"
	done
	
	echo "" > "$hostpath/temp/20-whitelist"
        cat "$hostpath/temp/$WDEVICE" | grep -v "^#\|^$" > $TEMP
	
	while read validtime vid pid serial 
	do
	        if [ -z "$serial" -a -z "$pid" ]
		then
	                echo "ATTR{idVendor}==\"$vid\", ENV{valid}=\"1\""  >> "$hostpath/temp/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ENV{valid}=\"2\""  >> "$hostpath/temp/20-whitelist"
		elif [ -z "$serial" ]
		then
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ENV{valid}=\"1\""  >> "$hostpath/temp/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ENV{valid}=\"2\""  >> "$hostpath/temp/20-whitelist"
	        else
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ATTR{serial}==\"$serial\", ENV{valid}=\"1\"" >> "$hostpath/temp/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ATTRS{serial}==\"$serial\", ENV{valid}=\"2\"" >> "$hostpath/temp/20-whitelist"
	        fi
	done < $TEMP
	
	for I in $hostpath/temp/[0-9]*
	do
		if [ ! -z "$(echo $I | grep '10-header$')" ]
		then
			cat $I > "$hostpath/etc/10-usblock.rules"
		else 
			cat $I >> "$hostpath/etc/10-usblock.rules"
		fi
	done
    fi

	#remove temp file
	[ -f "$TEMP" ] && rm $TEMP

	return 0
}

host_deploy_config() { 
	local hostid="$1"
	local mod=$2
	local result

	if [ "$develop" == "0" ] 
	then
		puppet kick $hostid >/dev/null 2>&1
		result=$?
		
		if [ "$result" != "0" ]
		then
			[ "$mod" != "silent" ] && dialog --msgbox "$hostid deployment failed." 6 50	
			echo "$hostid"	
		fi
	fi
	
}

group_modify_member() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)
	local oldmemberlist=$(mktemp /tmp/usb.XXXXXXX)
	local failedhost=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT $oldmemberlist; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local groupid
	local hostid
	local groupsum
	local hostsum
	local groupfilepath
	local reponse

	# if function had argument
	if [ ! -z "$1"	]
	then
		groupid="$1"
	else
	        # count number of group
	        groupsum=$(ls $GRPHOME | wc -l)
	
	        # choose group to modify
	        dialog --title "Group List" --menu "Choose one group to add/remove member" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $OUTPUT
	
	        local groupid=$(<$OUTPUT)
	
	        # if user select cancel
	        if [ -z "$groupid" ]
	        then
	                # remove temp file
	                [ -f "$OUTPUT" ] && rm $OUTPUT
		        [ -f "$oldmemberlist" ] && rm $oldmemberlist
	
	                return 1
	        fi
	fi

	hostsum=$(ls $CLIENHOME | wc -l)

        # choose hosts to add to group
        dialog --title "Choose host(s)" --checklist "Choose one/more host(s) for add to group" 10 60 $hostsum $(for i in $(ls $CLIENTHOME/); do echo "$i ${i%%.*} $(group_find_member $groupid $i) " | tr -d "\n"; done) 2> $OUTPUT

	# get response
	response=$?

        # if user press cancel
        if [ "$response" == "1" -o "$response" == "255" ]
        then
                # remove temp file
                [ -f "$OUTPUT" ] && rm $OUTPUT
        	[ -f "$oldmemberlist" ] && rm $oldmemberlist

                return 1
        fi

	# remove all old member
	find $CLIENTHOME -type f -name "grp.$groupid" -exec sh -c "echo -n '{} ' >> $oldmemberlist" \;

	[ ! -z "$(<$OUTPUT)" ] && for hostid in $(<$OUTPUT)
	do
		rm $CLIENTHOME/$hostid/temp/grp.* 2> /dev/null
		touch $CLIENTHOME/$hostid/temp/grp.$groupid

		# remove from old list
		groupfilepath=$CLIENTHOME/$hostid/temp/grp.$groupid
		sed -i 's_'"$groupfilepath"'__' $oldmemberlist

		[ ! -z "$hostid" ] && host_write_rule $hostid
	done

	[ ! -z "$(<$OUTPUT)" ] && for hostid in $(<$OUTPUT)
	do
		if [ ! -z "$hostid" ] 
		then
			host_deploy_config $hostid silent >> $failedhost                                                                         
		fi
	done

	# Remove old member from group
	[ ! -z "$(<$oldmemberlist)" ] && for I in $(<$oldmemberlist)
	do
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		rm -r $CLIENTHOME/$hostid/temp/grp.* 2> /dev/null
		[ ! -z "$hostid" ] && host_write_rule $hostid
	done

	# Deploy new config for removed member
	for I in $(<$oldmemberlist)
	do
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		if [ ! -z "$hostid" ] 
		then
			host_deploy_config $hostid silent >> $failedhost
		fi
	done

        if [ -z "$(<$failedhost)" ]    
        then
                echo "Client configuration deployment Process successfuly done." > $failedhost
                dialog --backtitle "Group Management" --title "Client Deployment" --textbox $failedhost 10 80
        else
                dialog --backtitle "Group Management" --title "Failed Host(s)" --textbox $failedhost 10 80
        fi


        # remove temp file
        [ -f "$OUTPUT" ] && rm $OUTPUT
        [ -f "$oldmemberlist" ] && rm $oldmemberlist

        return 0
		
       for hostid in $(<$OUTPUT)       
        do
            if [ "$hostid" == all ]        
            then              
                for hostid in $(ls $CLIENTHOME)
                do            
                    host_write_rule $hostid        
                    host_deploy_config $hostid silent >> $failedhost                                                                         
                done
                break         
            fi
            host_write_rule $hostid        
            host_deploy_config $hostid silent >> $failedhost                                                                                 
        done

}

group_modify() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# group name variable
	local groupid
	local groupsum

	# show list of groups
	# count number of group
	groupsum=$(ls $GRPHOME | wc -l)
	
	# if no any group 
	if [ "$groupsum" == "0" ] 
	then
		dialog --backtitle "Group Management" --title "Modify Group" --msgbox "No Groups" 6 30

		return 1
	fi

        # choose group to modify
        dialog --backtitle "Group Management" --title "Group List" --menu "Choose one group to modify" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $OUTPUT

	# get response
	response=$?

	# save dialog output in variable
	groupid=$(<$OUTPUT)
	
	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$OUTPUT" ] && rm $OUTPUT
		
		return 1
	fi
	
	# modify group
	group_modify_rule $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $GRPHOME/$groupid
		[ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi

	# modify member
	group_modify_member $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $GRPHOME/$groupid
		[ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
				
	return 0
}

group_add() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# group name variable
	local groupid
	
	while true
	do
		dialog --inputbox "Enter name of new group\nName must be 3 character at least\nOnly use Lowercase Alphabet and Digits" 10 50 2> $OUTPUT

		# get response
		response=$?

		# save dialog output in variable
		groupid=$(<$OUTPUT)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
			
			return 1
		fi
	
		# validate group name 
		if [ -z "$(echo "$groupid" | egrep "[a-z0-9]{3,}")" ] 
		then
			dialog --msgbox "Group name not accepted, please use valid format." 6 60
		elif [ ! -z "$(ls $GRPHOME | grep "^${groupid}$")" ]
	        then
	                dialog --msgbox "This Group already exists.\nPlease choose another name or use\nmodify group menu for add member" 7 40
		else 
			mkdir $GRPHOME/$groupid
			cp -ar $TEMPHOME/group/* $GRPHOME/$groupid
		
			break
		fi
	done

	# modify group
	group_modify_rule $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $GRPHOME/$groupid
		[ -f "$OUTPUT" ] && rm $OUTPUT
		dialog --backtitle "Group Management" --title "Adding Group Failed !"  --msgbox "Adding group failed during error or user cancelation." 5 60
		return 1
	fi

	# modify member
	group_modify_member $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $GRPHOME/$groupid
		[ -f "$OUTPUT" ] && rm $OUTPUT
		dialog --backtitle "Group Management" --title "Adding Group Failed !"  --msgbox "Adding group failed during error or user cancelation." 5 60
		return 1
	fi

	dialog --backtitle "Group Management" --msgbox "Group added successfully." 5 30

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
				
	return 0
}

group_del() {
	# wish list
	# featur 1: add soft delete
	# temp variables
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)
	local oldmemberlist=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT $oldmemberlist; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local groupid
	local hostid
	local groupsum
	local response

	# choose group from list
	# if function had argument
	if [ ! -z "$1"	]
	then
		groupid="$1"
	else
	        # count number of group
	        groupsum=$(ls $GRPHOME | wc -l)
	
		# back to ment if not any group
		if [ "$groupsum" == "0" ]
		then
			echo "Not any group exist yet." > $OUTPUT
			dialog --backtitle "Group Management" --title "Delete Group Memeber(s)" --textbox $OUTPUT 5 50

			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
        		[ -f "$oldmemberlist" ] && rm $oldmemberlist

			return 1
		fi

	        # choose group to modify
	        dialog --backtitle "Group Management" --title "Group List" --menu "Choose one group to add/remove member" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $OUTPUT
	
		# get response
		response=$?

	        local groupid=$(<$OUTPUT)
	
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
        		[ -f "$oldmemberlist" ] && rm $oldmemberlist
			
			return 1
		fi

	fi

	# are you sure
	dialog --backtitle "Group Management" --title " Warning " --yesno "Do you realy want to delete?\nThis task cant recover after progress" 6 50
	# get response
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$OUTPUT" ] && rm $OUTPUT
        	[ -f "$oldmemberlist" ] && rm $oldmemberlist
		
		return 1
	fi

	# remove member from group (progress 25%)
	echo 25 | dialog --backtitle "Group Management" --gauge "Remove $groupid members" 7 70 0
	find $CLIENTHOME -type f -name "grp.$groupid" -exec sh -c "echo -n '{} ' >> $oldmemberlist" \;
	for I in $(<$oldmemberlist)
	do
		rm -r $I
	done
	sleep 1
	
	# add default host rule to hosts (progress 50%)
	echo 50 | dialog --backtitle "Group Management" --gauge "Recovering hosts rules" 7 70 0
	for I in $(<$oldmemberlist)
	do
		
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		[ ! -z "$hostid"] && host_write_rule $hostid
	done
	sleep 1


	# deploy rule to removed host (progress 75%)
	echo 75 | dialog --backtitle "Group Management" --gauge "Deploy new rule to hosts" 7 70 0
	for I in $(<$oldmemberlist)
	do
		hostid=$(echo $i |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		[ ! -z "$hostid" ] && host_deploy_config $hostid
	done
	sleep 1

	# remove group folder (progress 90%)
	echo 90 | dialog --backtitle "Group Management" --gauge "Remove $groupid files" 7 70 0
	rm -r $GRPHOME/$groupid
	sleep 1

	# progress 100%
	echo 100 | dialog --backtitle "Group Management" --gauge "Remove $groupid files" 7 70 0
	sleep 1

	dialog --msgbox "$groupid removed successfuly" 6 45

        # remove temp file
        [ -f "$OUTPUT" ] && rm $OUTPUT
        [ -f "$oldmemberlist" ] && rm $oldmemberlist

        return 0
	
}

group_show() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local response
	local groupid
	local groupsum

	while true
	do
		# show list of groups
	        # count number of group
	        groupsum=$(ls $GRPHOME | wc -l)
	
	        # choose group to modify
	        dialog --title "Group List" --menu "Choose a group. Press cancel to exit and Esc to start again" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i $i " | tr -d "\n"; done) 2> $OUTPUT
	
		# get response
		response=$?

	        local groupid=$(<$OUTPUT)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" ]
		then 
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
			
			return 1
		elif [ "$response" == "255" ] 
		then 
			continue
		fi

		# show member in text box
find $CLIENTHOME -name "grp.$groupid" | sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_" > $OUTPUT

		dialog --backtitle "Group Management" --title "Group Member(s)" --textbox $OUTPUT 10 80

		if [ "$response" == "255" ]
		then
			continue
		fi

		# show class
		# Convert to human readable text
		sed -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/01/01h Audio/' \
		        -e 's/02/02h Communications and CDC Control/' \
		        -e 's/03/03h HID (Human Interface Device)/' \
		        -e 's/05/05h Physical/' \
		        -e 's/06/06h Image/' \
		        -e 's/07/07h Printer/' \
		        -e 's/08/08h Mass Storage/' \
		        -e 's/09/09h Hub/' \
		        -e 's/0A/0Ah CDC-Data/' \
		        -e 's/0B/0Bh Smart Card/' \
		        -e 's/0D/0Dh Content Security/' \
		        -e 's/0E/0Eh Video/' \
		        -e 's/0F/0Fh Personal Healthcare/' \
		        -e 's/10/10h Audio\/Video Devices/' \
		        -e 's/11/11h Billboard Device Class/' \
		        -e 's/12/12h USB Type-C Bridge Class/' \
		        -e 's/DC/DCh Diagnostic Device/' \
		        -e 's/E0/E0h Wireless Controller/' \
		        -e 's/EF/EFh Miscellaneous/' \
		        -e 's/FF/FEh Application Specific/' \
		        -e 's/FF/FFh Vendor Specific/'  $GRPHOME/$groupid/$WCLASS | \
							grep -v "^$" > $OUTPUT
		if [ -z "$(<$OUTPUT)" ]
		then
			echo "There is not exist any class in white list" > $OUTPUT
		fi
		dialog --backtitle "Group Management" --title "Whitelist Class" --textbox $OUTPUT 10 80

		# get response
		response=$?

		if  [ "$response" == "255" ]
		then
			continue
		fi
	
		# show device rule
		# change unix time to normal time
		sed 's|\(^[1-9][0-9]*\)\( .*\)|date --date=@\1 +%Y/%m/%d-%H:%M"\2"|e' $GRPHOME/$groupid/$WDEVICE | cat -s > $OUTPUT
		if [ -z "$(<$OUTPUT)" ]
		then
			echo "There is not exist any device in white list" > $OUTPUT
		fi

		dialog --backtitle "Group Management" --title "White List Device(s)" --textbox $OUTPUT 10 80

		# get response
		response=$?

		if [ "$response" == "1" ]
		then
			break
		elif [ "$response" == "255" ]
		then
			continue
		fi

	done

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
				
	return 0

}

yasa_admin_log(){
	# local variables
	local section=$1
	shift
	local message=$@

	# check ADMIN LOG is active?
	if [ "$ADMIN_LOG" == "0" -o "$ADMIN_LOG" == "off" -o "$ADMIN_LOG" == "false" ]
	then
		return 1
	fi	

	logger -p local1.info "Yasa Admin Log,$section:	$message"

	return 0
}

report_log() {
	echo "N"
}

report_peruser() {
	echo "N"
}

report_indays() {
	echo "N"
}

rule_exist() {
	local hostid="$1"
        local vendorid="$2"
        local productid="$3"
        local serial="$4"

	# return 1 if device not added 
	[ -z $(grep ".*$vendorid.*$productid.*$serial.*" $CLIENTHOME/$hostid/temp/$WDEVICE | cut -f 1 -d " ") ] && return 1

	# return 0 if device already exist 
	return 0
}

def_rule_exist() {
	local hostid="$1"
        local class="$2"

	# return 1 not exist
        [ -z $(grep -o "$class" $CLIENTHOME/$hostid/temp/$WCLASS | cut -f 1 -d " ") ] && return 1

	# retrun 0 if class exit in whitelist
        return 0

}

host_if_member() {
	local hostid="$1"
	local membership=$(ls $CLIENTHOME/$hostid/temp/grp.* 2>/dev/null)

	if [ -z "$membership" ]
	then
		return 1
	else
		echo ${membership##*.}
		return 0
	fi
}

write_rule() {
	# temperorly file 
	TEMP=$(mktemp /tmp/usb.XXXXXXXX)

	# trap and delete temp file
	trap "rm $TEMP; exit" SIGHUP SIGINT SIGTERM

	local basepath="$1"

	echo "" > "$basepath/temp/25-default-whitelist"
	cat "$basepath/temp/$WCLASS" | grep -v "^#\|^$" | while read line; do
                echo "ATTR{bInterfaceClass}==\"$line\", ENV{valid}=\"2\""  >> "$basepath/temp/25-default-whitelist"
	done
	
	local ar=()

	echo "" > "$basepath/temp/20-whitelist"
        cat "$basepath/temp/$WDEVICE" | grep -v "^#\|^$" > $TEMP
	
	while read validtime vid pid serial 
	do
		#ar=($(echo ${loop}))
		#        echo ""
	        # [ "$comment" ] && echo "# $comment"
	        if [ -z "$serial" ]; then
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ENV{valid}=\"1\""  >> "$basepath/temp/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ENV{valid}=\"2\""  >> "$basepath/temp/20-whitelist"
	        else
	                echo "ATTR{idVendor}==\"$vid\", ATTR{idProduct}==\"$pid\", ATTR{serial}==\"$serial\", ENV{valid}=\"1\"" >> "$basepath/temp/20-whitelist"
	                echo "ATTRS{idVendor}==\"$vid\", ATTRS{idProduct}==\"$pid\", ATTRS{serial}==\"$serial\", ENV{valid}=\"2\"" >> "$basepath/temp/20-whitelist"
	        fi
	done < $TEMP
	
	for I in $basepath/temp/[0-9]*
	do
		if [ ! -z "$(echo $I | grep '10-header$')" ]
		then
			cat $I > "$basepath/etc/10-usblock.rules"
		else 
			cat $I >> "$basepath/etc/10-usblock.rules"
		fi
	done

	[ -f "$TEMP" ] && rm $TEMP
	return 0
}


addnew() {
	local validtime=0
	local currenttime
	local hostid
	local response

	# temperorly file 
	local INPUT1=$(mktemp /tmp/usb.XXXXXXXX)
	local INPUT2=$(mktemp /tmp/usb.XXXXXXXX)
	
	# menu output
	local OUTPUT=$(mktemp /tmp/output.XXXXXXX)

	# define local array
	local ar=()
	local newwhite=()

	# trap and delete temp file
	trap "rm $INPUT1 $INPUT2 $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	tail /var/log/usblock.log | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' >$INPUT2
	cat "$INPUT2" | cut -f 1,3,5,6,7,8 -d " " > "$INPUT1"
	while read n s ; do
	    ar+=($n "$s")
	done < $INPUT1
	dialog  --title "10 Latest Devices" --menu "Your choozen device will be add to whitelist" 0 80 5 "${ar[@]}" 2> $OUTPUT

	NUM=$(<$OUTPUT)

	# if user choose cancel
	if [ "$NUM" = "" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 1
	fi
	newwhite=($(sed -n "$NUM p" $INPUT1))

	# get hostid
	hostid=${newwhite[1]#*:}

	host_if_member $hostid

	# get response
	response=$?

	if [ "$response" == "0" ]
	then
		groupid=$(host_if_member $hostid)
		dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

		# remove temp file if exist
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 1

	fi

	if [ -z "$(ls $CLIENTHOME | grep "^${newwhite[1]#*:}$")" ]
        then
                dialog --msgbox "This host not added to yasa befor.\nPlease use \"Add new host\" in Main menu" 7 45
                [ -f "$INPUT1" ] && rm $INPUT1
                [ -f "$INPUT2" ] && rm $INPUT2
                [ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	elif  rule_exist ${newwhite[1]#*:} ${newwhite[3]#*:} ${newwhite[4]#*:} ${newwhite[5]#*:}
	then
		# check if device added befor
	 	dialog --msgbox "Device already exist in whitelist" 5 38
                [ -f "$INPUT1" ] && rm $INPUT1
                [ -f "$INPUT2" ] && rm $INPUT2
                [ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi
	# input comment
	dialog --inputbox "Write comment for this device" 8 80 "no comment" 2> $OUTPUT
	local comment=$(<$OUTPUT)

	# if user choose cancel
	if [ -z "$comment" ]
	then
		# remove temp file if exist
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 0
	fi

	# input box for enter validation time in houre
	while true
	do
		dialog --inputbox "Please enter validation time in houre (enter 0 or leave blank for unlimite time)" 8 80 0 2> $OUTPUT
		validtime=$(<$OUTPUT)

		# if user choose cancel
		if [ -z "$validtime" ]
		then
			# remove temp file if exist
			[ -f "$INPUT1" ] && rm $INPUT1
			[ -f "$INPUT2" ] && rm $INPUT2
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 0
		fi


		if [ -z "$validtime" ] || [ "$validtime" = "0" ]
		then
			validtime=0
			break
		elif [ ! -z "$(echo $validtime | grep '^[1-9][0-9]*$')" ]
		then
			currenttime=$(date +"%s")
			validtime=$(( $validtime * 60 * 60 + $currenttime ))
			break
		fi
	done

	# add new device to white list
	echo -e "# comment $comment \n# ${newwhite[1]} ${newwhite[2] } \n$validtime ${newwhite[3]#*:} ${newwhite[4]#*:} ${newwhite[5]#*:}\n" >> $CLIENTHOME/${newwhite[1]#*:}/temp/$WDEVICE
		
	write_rule "$CLIENTHOME/${newwhite[1]#*:}"
	dialog --msgbox "Device added successfully" 5 30

	# remove temp file if exist
	[ -f "$INPUT1" ] && rm $INPUT1
	[ -f "$INPUT2" ] && rm $INPUT2
	[ -f "$OUTPUT" ] && rm $OUTPUT

	[ "$develop" != 1 ] &&  puppet kick ${newwhite[1]#*:}

	return 0	
}

addnewip() {
	local validtime=0
	local currenttime

	# temperorly file 
	local INPUT1=$(mktemp /tmp/usb.XXXXXXXX)
	local INPUT2=$(mktemp /tmp/usb.XXXXXXXX)
	
	# menu output
	local OUTPUT=$(mktemp /tmp/output.XXXXXXX)

	# define local array
	local ar=()
	local newwhite=()

	# trap and delete temp file
	trap "rm $INPUT1 $INPUT2 $OUTPUT; exit" SIGHUP SIGINT SIGTERM
	
	# search based on ip address
	dialog --inputbox "Please enter ip address or hostname for search in log file" 8 80 2> $OUTPUT

	# save input variable
	ipadd=$(<$OUTPUT)

	# if user cancel the dialog
	if [ -z "$ipadd" ]
	then
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT
	
		return 0
	fi

	cat /var/log/usblock.log | grep -i "$ipadd" | tail | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' >$INPUT2
	cat "$INPUT2" | cut -f 1,3,5,6,7,8 -d " " > "$INPUT1"
	while read n s ; do
	    ar+=($n "$s")
	done < $INPUT1
	dialog  --title "Founded devices" --menu "Your choozen device will be add to whitelist" 0 80 5 "${ar[@]}" 2> $OUTPUT

	NUM=$(<$OUTPUT)
	
	# if user choose cancel
	if [ "$NUM" = "" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 0
	fi

	# pick log line
	newwhite=($(sed -n "$NUM p" $INPUT1))

	# get hostid
	hostid=${newwhite[1]#*:}

	host_if_member $hostid

	# get response
	response=$?

	if [ "$response" == "0" ]
	then
		groupid=$(host_if_member $hostid)
		dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

		# remove temp file if exist
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 1

	fi

	# check if host exist
	if [ -z "$(ls $CLIENTHOME | grep "^${newwhite[1]#*:}$")" ]
        then
                dialog --msgbox "This host is not exists.\nPlease add it in Add new host menu" 6 40
		
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 0
	fi

	# check if device added befor
	rule_exist ${newwhite[1]#*:} ${newwhite[3]#*:} ${newwhite[4]#*:} ${newwhite[5]#*:} && dialog --msgbox "Device already exist in whitelist" 5 38 && return 1

	# input comment
	dialog --inputbox "Write comment for this device" 8 80 "no comment" 2> $OUTPUT
	local comment=$(<$OUTPUT)

	# if user choose cancel
	if [ -z "$comment"  ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 0
	fi

	# input box for enter validation time in houre
	while true
	do
		dialog --inputbox "Please enter validation time in houre (enter 0 or leave blank for unlimite time)" 8 80 0 2> $OUTPUT
		validtime=$(<$OUTPUT)

		# if user choose cancel
		if [ -z "$validtime"  ]
		then 
			# remove temp files
			[ -f "$INPUT1" ] && rm $INPUT1
			[ -f "$INPUT2" ] && rm $INPUT2
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 0
		fi

		if [ "$validtime" = "0" ]
		then
			break
		elif [ ! -z "$(echo $validtime | grep '^[1-9][0-9]*$')" ]
		then
			currenttime=$(date +"%s")
			validtime=$(( $validtime * 60 * 60 + $currenttime ))
			break
		fi
	done


	# add new device to white list
	echo -e "# comment $comment \n# ${newwhite[1]} ${newwhite[2] } \n${newwhite[3]#*:} ${newwhite[4]#*:} ${newwhite[5]#*:}\n" >> $CLIENTHOME/${newwhite[1]#*:}/temp/$WDEVICE
		
	write_rule "$CLIENTHOME/${newwhite[1]#*:}"

	# remove temp file if exist
	[ -f "$INPUT1" ] && rm $INPUT1
	[ -f "$INPUT2" ] && rm $INPUT2
	[ -f "$OUTPUT" ] && rm $OUTPUT
	
	[ "$develop" != 1 ] &&  puppet kick ${newwhite[1]#*:}

	return 0
}

addnewclass() {
	# temp file for dialog output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# choose between usb class
        /usr/bin/dialog --clear --backtitle "Usb lock main menu" \
        --title "[ List of USB Class ]" \
        --menu "Choose a class to add to whitelist" 13 60 6 \
	00h "Use class information in the Interface Descriptors" \
	01h "Audio"   \
	02h "Communications and CDC Control" \
	03h "HID (Human Interface Device)" \
	05h "Physical" \
	06h "Image" \
	07h "Printer" \
	08h "Mass Storage" \
	09h "Hub" \
	0Ah "CDC-Data" \
	0Bh "Smart Card" \
	0Dh "Content Security" \
	0Eh "Video" \
	0Fh "Personal Healthcare" \
	10h "Audio/Video Devices" \
	11h "Billboard Device Class" \
	12h "USB Type-C Bridge Class" \
	DCh "Diagnostic Device" \
	E0h "Wireless Controller" \
	EFh "Miscellaneous" \
	FEh "Application Specific" \
	FFh "Vendor Specific" 2> $OUTPUT
	
	# if user press cancel
	if [ -z $(<$OUTPUT) ]
	then
		# remove temp file
		[ -f "$OUTPUT" ] && rm $OUTPUT
	
		return 0
	fi	
	
	# save menu output
	local class=$(cat $OUTPUT | tr -d 'h')

	if [ ! -z "$class" ]
	then
		# count number of host
		local hostsum=$(ls $CLIENTHOME | wc -l)
		((hostsum++))
	
		dialog --title "Choose host(s)" --checklist "Choose one/more/all host(s) to update whitelist" 10 60 $hostsum all hosts off $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} off " | tr -d "\n"; done) 2> $OUTPUT
	
		# if user press cancel
		if [ -z $(<$OUTPUT) ]
		then
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
			
			return 0
		fi

		for i in $(<$OUTPUT)	
		do
			if [ "$i" == "all" ]
			then

				for j in $CLIENTHOME/*
				do
					# get hostid
					hostid=$j

					host_if_member $hostid

					# get response
					response=$?

					if [ "$response" == "0" ]
					then
						groupid=$(host_if_member $hostid)
						dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

						# remove temp file if exist
						[ -f "$OUTPUT" ] && rm $OUTPUT

						return 1

					fi

					def_rule_exist ${j##*/} $class && continue
					echo $class >> $j/temp/$WCLASS			
					write_rule "$j/"
				done
				break
			fi

			# get hostid
			hostid=$i

			host_if_member $hostid

			# get response
			response=$?

			if [ "$response" == "0" ]
			then
				groupid=$(host_if_member $hostid)
				dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

				# remove temp file if exist
				[ -f "$OUTPUT" ] && rm $OUTPUT

				return 1

			fi

			
			# if all not selected
			def_rule_exist $i $class && continue
			echo $class >> $CLIENTHOME/$i/temp/$WCLASS			
			write_rule $CLIENTHOME/$i
		done
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
	
	[ "$develop" != 1 ] &&  puppet kick ${newwhite[1]#*:}

	return 0
}


showwhitedev() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# count number of host
	local hostsum=$(ls $CLIENTHOME | wc -l)
	((hostsum++))

	while true
	do
		dialog --title "Choose host(s)" --menu "Choose one/more/all host(s) to show whitelist\nPress cancel to return Client Management menu" 13 60 $hostsum $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $OUTPUT
	
		# save menu output
		local hostid=$(<$OUTPUT)
		
		# if user press cancel
		if [ -z "$hostid" ]
		then
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 0
		fi

		host_if_member $hostid

		# get response
		response=$?

		if [ "$response" == "0" ]
		then
			groupid=$(host_if_member $hostid)
			dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

			# remove temp file if exist
			[ -f "$OUTPUT" ] && rm $OUTPUT

			return 1

		fi



		# change unix time to normal time
		sed 's|\(^[1-9][0-9]*\)\( .*\)|date --date=@\1 +%Y/%m/%d-%H:%M"\2"|e' $CLIENTHOME/$hostid/temp/$WDEVICE | cat -s > $OUTPUT
		dialog --textbox $OUTPUT 10 80
	done

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0
}

showwhiteclass() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# count number of host
	local hostsum=$(ls $CLIENTHOME | wc -l)
	((hostsum++))

	while true
	do
		dialog --title "Choose host(s)" --menu "Choose one/more/all host(s) to show whitelist\nPress cancel to return Client Management menu" 13 60 $hostsum $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $OUTPUT
	
		# save menu output
		local hostid=$(<$OUTPUT)
	
		# if user press cancel
		if [ -z "$hostid" ]
		then
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 0
		fi

		host_if_member $hostid

		# get response
		response=$?

		if [ "$response" == "0" ]
		then
			groupid=$(host_if_member $hostid)
			dialog --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55

			# remove temp file if exist
			[ -f "$OUTPUT" ] && rm $OUTPUT

			return 1

		fi

		# Convert to human readable text
		sed -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/01/01h Audio/' \
		        -e 's/02/02h Communications and CDC Control/' \
		        -e 's/03/03h HID (Human Interface Device)/' \
		        -e 's/05/05h Physical/' \
		        -e 's/06/06h Image/' \
		        -e 's/07/07h Printer/' \
		        -e 's/08/08h Mass Storage/' \
		        -e 's/09/09h Hub/' \
		        -e 's/0A/0Ah CDC-Data/' \
		        -e 's/0B/0Bh Smart Card/' \
		        -e 's/0D/0Dh Content Security/' \
		        -e 's/0E/0Eh Video/' \
		        -e 's/0F/0Fh Personal Healthcare/' \
		        -e 's/10/10h Audio\/Video Devices/' \
		        -e 's/11/11h Billboard Device Class/' \
		        -e 's/12/12h USB Type-C Bridge Class/' \
		        -e 's/DC/DCh Diagnostic Device/' \
		        -e 's/E0/E0h Wireless Controller/' \
		        -e 's/EF/EFh Miscellaneous/' \
		        -e 's/FF/FEh Application Specific/' \
		        -e 's/FF/FFh Vendor Specific/'  $CLIENTHOME/$hostid/temp/$WCLASS > $OUTPUT
	
		dialog --textbox $OUTPUT 10 80
	done

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0
}

deldev() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# count number of host
	local hostsum=$(ls $CLIENTHOME | wc -l)
	((hostsum++))

	# define array
	local ar=()

	dialog --title "Choose host" --menu "Choose a host to show whitelist" 10 60 $hostsum $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $OUTPUT

	# save menu output
	local hostid=$(<$OUTPUT)
	local linenum=0

	if [ ! -z "$hostid" ]
	then
		while read line 
		do
		        if [ ! -z "$(echo $line | grep "^# comment" )" ]
		        then
				((linenum++))
		                comment=$line; count=1;
		                continue
		        elif [ "$count" = "1" ] && [ ! -z "$(echo $line | grep "^# From")" ]
		        then
		                device=$(echo $line | grep -o "Device:.*$")
		                ar+=($linenum "$comment $device")
		                count=0
		        fi
		done <$CLIENTHOME/$hostid/temp/$WDEVICE	
		
		if [ -z "${ar[@]}" ]
		then
			dialog --msgbox "There isnt any device in whitelist" 5 40
			# remove temp file
			[ -f "$OUTPUT" ] && rm $OUTPUT
	
			return 0
		fi

		dialog  --title "List of white list" --menu "Choose one for delete from whitelist" 10 80 5 "${ar[@]}" 2> $OUTPUT
	
		# save menu output
		local devicenum=$(<$OUTPUT)
	fi

	if [ ! -z "$devicenum" ]
	then
		echo "" > $OUTPUT
		linenum=0
	
		while read line
		do
			if [ ! -z "$(echo $line | grep "^# comment")" ]
			then
				ucomment=$line
				((linenum++))
			elif [ ! -z "$(echo $line | grep "^# From:")" ]
			then
				scomment=$line
			elif [ ! -z "$(echo $line | grep "^[0-9]" )" ]
			then
				if  [ "$linenum" != "$devicenum" ]
				then
					echo -e "$ucomment\n$scomment\n$line" >> $OUTPUT
				fi
			else
				echo $line >> $OUTPUT
			fi
		done < $CLIENTHOME/$hostid/temp/$WDEVICE
	
	 	cat -s $OUTPUT > $CLIENTHOME/$hostid/temp/$WDEVICE	
		dialog --msgbox "Device deleted from whitelist" 5 35

		# generate udev rule
		write_rule "$CLIENTHOME/$hostid/"
	
		# run puppet kick
		[ "$develop" != 1 ] && puppet kick $hostid
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
	
	return 0
}

delclass() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# count number of host
	local hostsum=$(ls $CLIENTHOME | wc -l)
	((hostsum++))

	# define array
	local ar=()

	dialog --title "Choose host(s)" --menu "Choose one/more/all host(s) to show whitelist" 10 60 $hostsum $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $OUTPUT

	# save menu output
	local hostid=$(<$OUTPUT)

        # if user choose cancel
        if [ -z "$hostid" ]
        then
                # remove temp file
                [ -f "$OUTPUT" ] && rm $OUTPUT

                return 0
        fi

	dialog --title "Choose host(s)" --menu "Choose a class for delete from whitelist" 10 60 5 $(cat -n $CLIENTHOME/$hostid/temp/$WCLASS) 2> $OUTPUT

	local linenumber=$(<$OUTPUT)

	# if user choose cancel
	if [ -z "$linenumber" ]
	then
	        # remove temp file
	        [ -f "$OUTPUT" ] && rm $OUTPUT
	
		return 0
	fi

	local classnum=$(sed -n "$linenumber p" $CLIENTHOME/$hostid/temp/$WCLASS)
	if [ "$classnum" == "09" ]
	then
		dialog --title " Warning " --yesno "Delete \"09 Hub\" class, may cause disable all usb port. \nDo you realy want to delete?" 6 60
		local response=$?
		if [ "$response" == "0" ]
		then
			sed -i "$linenumber d" $CLIENTHOME/$hostid/temp/$WCLASS
		else
			# if select no
			# remove temp file
		        [ -f "$OUTPUT" ] && rm $OUTPUT

			return 0
		fi
	else
		sed -i "$linenumber d" $CLIENTHOME/$hostid/temp/$WCLASS
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	# generate udev rule
	write_rule "$CLIENTHOME/$hostid/"

	# run puppet kick
	[ "$develop" != 1 ] && puppet kick $hostid

	return 0

}

addnewhost() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# hostname variable
	local hostid

	dialog --inputbox "Enter new hostname FQDN (only use a-z and digits)" 10 60 2> $OUTPUT
	hostid=$(<$OUTPUT)

	# if user press cancel
	if [ -z "$hostid" ]
	then
		# remove temp file
		[ -f "$OUTPUT" ] && rm $OUTPUT
		
		return 0
	fi

	# validate hostname FQDN
	if [ -z "$(echo "$hostid" | egrep "^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][a-zA-Z0-9_-]{1,61}[a-zA-Z0-9]))\.([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,})$")" ] 
	then
		dialog --msgbox "Entered hostname is invalid, please use valid format" 6 60
		
	elif [ ! -z "$(ls $CLIENTHOME | grep "^$hostid$")" ]
	then
		dialog --msgbox "This host is exists" 5 25
	else
		mkdir -p $CLIENTHOME/$hostid 
		cp -ar /etc/yasa/skell/{etc,temp} $CLIENTHOME/$hostid
		write_rule $CLIENTHOME/$hostid
		if [ -d "$CLIENTHOME/$hostid" -a -d "$CLIENTHOME/$hostid/temp" ]
		then
			dialog --msgbox "Host added successfully" 5 30
		fi
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	# run puppet kick
	[ "$develop" != 1 ] && puppet kick $hostid

	return 0

}

delhost() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# hostname variable
	local hostid
	

	# list all hosts
	dialog --title "Choose host(s) to delete from Yasa" --checklist "Choose one/more/all host(s) to delete from Yasa" 11 60 10 all hosts off $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} off " | tr -d "\n"; done) 2> $OUTPUT
	
	# if user press cancel
	if [ -z "$(cat $OUTPUT)" ]
	then 
	        # remove temp file
	        [ -f "$OUTPUT" ] && rm $OUTPUT

        	return 0
	fi

	dialog --title " Warning " --yesno "Do you realy want delete (a) host(s)?" 6 50
	local response=$?
        if [ "$response" == "1" ]
        then
                 # remove temp file
                 [ -f "$OUTPUT" ] && rm $OUTPUT

                 return 0
        fi

	for i in $(<$OUTPUT)	
		do
			# if all selected
			if [ "$i" == "all" ]
			then
				dialog --title " Warning " --yesno "After delete all hosts you cant manage any change on hosts. \nDo you realy want delete all hosts?" 7 60
		                local response=$?
		                if [ "$response" == "0" ]
		                then
					rm -r  $CLIENTHOME/* && dialog --msgbox "All hosts deleted successfuly." 5 40
		                fi
				break

			        # remove temp file
			        [ -f "$OUTPUT" ] && rm $OUTPUT
	
        			return 0

			fi
			
			# if all not selected
			rm -r $CLIENTHOME/$i
	done
	
	dialog --msgbox "Host(s) deleted successfuly." 5 40

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0
}

trigger_def() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# hostname variable
	local hostid

        # count number of host
        local hostsum=$(ls $CLIENTHOME | wc -l)
        ((hostsum++))

	#dialog --title "Choose host(s)" --checklist "Choose one/more/all host(s) to update whitelist" 10 60 $hostsum all hosts off $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} off " | tr -d "\n"; done) 2> $OUTPUT
        dialog --title "Choose host(s)" --menu "Choose one host to active/deactive restrictions" 10 60 $hostsum $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $OUTPUT

        # save menu output
        local hostid=$(<$OUTPUT)

	if [ -z "$hostid" ]
	then
		# user press cancel
		# remove temp file
		[ -f "$OUTPUT" ] && rm $OUTPUT

		return 0
	elif [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "0" ]
	then
		sed -i 's/devpath 0/devpath 1/' $CLIENTHOME/$hostid/temp/90-footer
		echo "1" > $CLIENTHOME/$hostid/temp/$WDEF
		dialog --msgbox "USB Restrictions Deactivated" 5 40
	else
		sed -i 's/devpath 1/devpath 0/' $CLIENTHOME/$hostid/temp/90-footer
		echo "0" > $CLIENTHOME/$hostid/temp/$WDEF
		dialog --msgbox "USB Restrictions Activated" 5 40
	fi
	
        # generate udev rule
        write_rule "$CLIENTHOME/$hostid/"

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	# run puppet kick
	[ "$develop" != 1 ] && puppet kick $hostid
}

report_active() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	for i in $CLIENTHOME/*
	do 
		if [ "$(cat $i/temp/default)" == "0" ]
		then
			j=${i##*/} 
			echo "$j" >> $OUTPUT
		fi
	done
	dialog --textbox $OUTPUT 10 40	

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0

}

report_deactive() {
	# temp file for menu output
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	for i in $CLIENTHOME/*
	do 
		if [ "$(cat $i/temp/default)" == "1" ]
		then
			j=${i##*/} 
			echo "$j" >> $OUTPUT
		fi
	done
	dialog --textbox $OUTPUT 10 40	
	
	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0

}

install_client_wizard() {
	# client connection information
	local hostname
	local username
	local password
	
	

}

yasa_paration() {
	echo N	
}
                                                                
force_client_update() {
	# temperorly file 
        OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)
	failedhost=$(mktemp /tmp/usb.XXXXXXXX)

        # trap and delete temp file
        trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM
        trap "rm $failedhost; exit" SIGHUP SIGINT SIGTERM

	# local variables
	local hostid
	local response
	local hostsum

	hostsum=$(ls $CLIENHOME | wc -l)

	dialog --title "Choose host(s)" --checklist "Choose one/more/all host(s) to update whitelist" 10 60 $hostsum all hosts off $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} off " | tr -d "\n"; done) 2> $OUTPUT
	
	# get response
	response=$?

	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$OUTPUT" ] && rm $OUTPUT
		[ -f "$failedhost" ] && rm $failedhost
		return 1
	fi

	if [ -z "$(<$OUTPUT)" ]
	then
		[ -f "$OUTPUT" ] && rm $OUTPUT
		[ -f "$failedhost" ] && rm $failedhost
		return 1
	fi

	for hostid in $(<$OUTPUT)	
	do
	    if [ "$hostid" == all ]
	    then
		for hostid in $(ls $CLIENTHOME)
		do
		    host_write_rule $hostid
		    host_deploy_config $hostid silent >> $failedhost		
		done
		break
	    fi
	    host_write_rule $hostid
	    host_deploy_config $hostid silent >> $failedhost		
	done

	if [ -z "$(<$failedhost)" ]
	then
		echo "Client configuration deployment Process successfuly done." > $failedhost
		dialog --backtitle "Yasa Management" --title "Client Deployment" --textbox $failedhost 10 80
	else
		dialog --backtitle "Yasa Management" --title "Failed Host(s)" --textbox $failedhost 10 80
	fi

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT
	[ -f "$failedhost" ] && rm $failedhost

	return 0

} 

accept_ready_client() {
	# temperorly file 
        OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)

        # trap and delete temp file
        trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local hostid
	local hostsum=$(puppet cert list | wc -l)
	
	if [ "$hostsum" == "0" ] 
	then
		echo "Not any client exist in waiting list" > $OUTPUT
		dialog --backtitle "Yasa Management" --title "Accept New Client" --textbox $OUTPUT 5 50
		[ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi

	dialog --title "Choose host(s)" --checklist "Choose one/more/all host(s) to update whitelist" 10 60 $hostsum all hosts off $(for i in $(puppet cert list | tr -s ' ' | sed 's/ \"/\"/' | cut -f 1 -d " " | tr -d '"'); do echo "$i ${i%%.*} off " | tr -d "\n"; done) 2> $OUTPUT

	# get response
	response=$?

	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi

	if [ -z "$(<$OUTPUT)" ]
	then
		[ -f "$OUTPUT" ] && rm $OUTPUT
		return 1
	fi

	for hostid in $(<$OUTPUT)	
	do
	    if [ "$hostid" == all ]
	    then
		for hostid in $(ls $CLIENTHOME)
		do
		    puppet cert sign $hostid
		done
		break
	    fi
	    puppet cert sign $hostid
	done

	# remove temp file
	[ -f "$OUTPUT" ] && rm $OUTPUT

	return 0
}

yasacron() {
        # temperorly file 
        TEMP=$(mktemp /tmp/usb.XXXXXXXX)

        # trap and delete temp file
        trap "rm $TEMP; exit" SIGHUP SIGINT SIGTERM

	# save current time
	local currenttime=$(date +"%s")

	# variable for save dev.allow line
	local scomment
	local ucomment
	local line

	# remove dev allow rule based on expire time
	for host_dir in $CLIENTHOME/*
	do
		if [ -d "$host_dir" ]
		then
			while read line
			do
				if [ ! -z "$(echo $line | grep "^# comment")" ]
				then
					ucomment=$line
				elif [ ! -z "$(echo $line | grep "^# From:")" ]
				then
					scomment=$line
				elif [ ! -z "$(echo $line | grep "^[0-9]" )" ]
				then
					if [ ! -z "$(echo $line  | awk '($1 > value ) ' value=$currenttime)" ]
					then
						echo -e "$ucomment\n$scomment\n$line" >> $TEMP
					fi
				else
					echo $line >> $TEMP
				fi
			done < $host_dir/temp/$WDEVICE
			cp $TEMP $host_dir/temp/$WDEVICE
		else
			continue
		fi

		# write rule for each
		write_rule $host_dir

		# deploy rule for each host
		[ "$develop" != 1 ] && puppet kick $hostid
	done

	# remove class based on expire time
	# not implemented

	# remove temp file
	[ -f "$TEMP" ] && rm $TEMP

}

yasaauth() {
	local name=/sys$1
	local value=$2
	echo "$value" > "${name%/*}/authorized" 2>> /dev/null
	echo "${name%/*}/authorized" >> /var/log/yasa-auth.log
	return 0
}

client_mgmt_menu() {
	# Menu input
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)
	
	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM
	
	while true
	do
	        ### display main menu ###
	        /usr/bin/dialog --clear --backtitle "Client Management Menu" \
	        --title "[ C L I E N T - M E N U ]" \
	        --menu "You can use the UP/DOWN arrow keys, the first \
	        letter of the choice as a hot key, or the \
	        number keys 1-9 to choose an option.\
	        Choose the TASK" 20 65 13 \
		1 "Add new host" \
		2 "Delete hosts" \
	        3 "Add new device based on last ten entry" \
	        4 "Add new device based on client IP address" \
		5 "Add new class to white list" \
		6 "Show device white list" \
		7 "Show class white list" \
		8 "Delete device from white list" \
		9 "Delete class from white list" \
		10 "Trigger state (allow all/deny all)" \
	        Exit "Return to Main Menu" 2>"${OUTPUT}"
	
	        local menuitem=$(<"${OUTPUT}")

		# if user enter cancel
		if [ -z "$menuitem" ]
		then
		        # remove temp file
		        [ -f "$OUTPUT" ] && rm $OUTPUT

			return 0
		fi

	        # make decision
	        case $menuitem in
			1) addnewhost;;
			2) delhost;;
	                3) addnew;;
	                4) addnewip;;
			5) addnewclass;;
			6) showwhitedev;;
			7) showwhiteclass;;
			8) deldev;;
			9) delclass;;
			10) trigger_def;;
	                Exit) echo "Bye"; break;;
	        esac
	

	done	
	return 0
}

group_mgmt_menu() {
	# Menu input
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)
	
	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	while true
	do
	        ### display main menu ###
	        /usr/bin/dialog --clear --backtitle "Yasa Group Management Menu" \
	        --title "[ GROUP - M E N U ]" \
	        --menu "You can use the UP/DOWN arrow keys, the first \
	        letter of the choice as a hot key, or the \
	        number keys 1-9 to choose an option.\
	        Choose the TASK" 16 60 6 \
		1 "Add new group" \
		2 "Delete a group" \
		3 "Modify group" \
		4 "Show group (show member and rules)" \
	        Exit "Return to Main Menu" 2>"${OUTPUT}"
	
	        local menuitem=$(<"${OUTPUT}")

		# if user enter cancel
		if [ -z "$menuitem" ]
		then
		        # remove temp file
		        [ -f "$OUTPUT" ] && rm $OUTPUT

			return 0
		fi
	
	        # make decision
	        case $menuitem in
			1) group_add;;
			2) group_del;;
			3) group_modify;;
			4) group_show;;
	                Exit) break;;
	        esac
	

	done	
	return 0
}

report_menu() {
	# Menu input
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)
	
	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	while true
	do
	        ### display main menu ###
	        /usr/bin/dialog --clear --backtitle "Yasa Report Menu" \
	        --title "[ R E P O R T - M E N U ]" \
	        --menu "You can use the UP/DOWN arrow keys, the first \
	        letter of the choice as a hot key, or the \
	        number keys 1-9 to choose an option.\
	        Choose the TASK" 12 55 6 \
		1 "Show restricted client" \
		2 "Show full access client" \
	        Exit "Return to Main Menu" 2>"${OUTPUT}"
	
	        local menuitem=$(<"${OUTPUT}")

		# if user enter cancel
		if [ -z "$menuitem" ]
		then
		        # remove temp file
		        [ -f "$OUTPUT" ] && rm $OUTPUT

			return 0
		fi
	
	        # make decision
	        case $menuitem in
			1) report_active;;
			2) report_deactive;;
	                Exit) break;;
	        esac
	

	done	
	return 0
}

yasa_mgmt_menu() {
	# Menu input
	local OUTPUT=$(mktemp /tmp/usb.XXXXXXXX)
	
	# trap and delete temp file
	trap "rm $OUTPUT; exit" SIGHUP SIGINT SIGTERM

	while true
	do
	        ### display main menu ###
	        /usr/bin/dialog --clear --backtitle "Yasa Install Menu" \
	        --title "[ M A N A G E M E M E N T - M E N U ]" \
	        --menu "You can use the UP/DOWN arrow keys, the first \
	        letter of the choice as a hot key, or the \
	        number keys 1-9 to choose an option.\
	        Choose the TASK" 14 60 9 \
		1 "Intall new client wizard" \
		2 "Prepare server installation" \
		3 "Force Client Update" \
		4 "Accept Ready Client" \
	        Exit "Return to Main Menu" 2>"${OUTPUT}"
	
	        local menuitem=$(<"${OUTPUT}")

		# if user enter cancel
		if [ -z "$menuitem" ]
		then
		        # remove temp file
		        [ -f "$OUTPUT" ] && rm $OUTPUT

			return 0
		fi
	
	        # make decision
	        case $menuitem in
			1) install_client_wizard;;
			2) yasa_paration;;
			3) force_client_update;;
			4) accept_ready_client;;
	                Exit) break;;
	        esac
	

	done	
	return 0
}

# Non-interactive mod
if [ ! -z "$1" ]
then
	if [ "$1" = "cron" ]
	then
		yasacron
	elif [ "$1" = "auth" ]
	then
		yasaauth $2 $3
	fi

# Interactive mod
else
	# Menu input
	MAININPUT=$(mktemp /tmp/usb.XXXXXXXX)
	
	# trap and delete temp file
	trap "rm $MAININPUT; exit" SIGHUP SIGINT SIGTERM
	
	while true
	do
	        ### display main menu ###
	        /usr/bin/dialog --clear --backtitle "Usb lock main menu" \
	        --title "[ M A I N - M E N U ]" \
	        --menu "You can use the UP/DOWN arrow keys, the first \
	        letter of the choice as a hot key, or the \
	        number keys 1-4 to choose an option.\
	        Choose the TASK" 15 65 5 \
		1 "Client Management" \
		2 "Group Management" \
	        3 "Reports" \
	        4 "Yasa Management and Utility" \
	        Exit "Exit and Logout" 2>"${MAININPUT}"
	
	        menuitem=$(<"${MAININPUT}")
	
		if [ -z "$menuitem" ]
		then
		        # remove temp file
		        [ -f "$MAININPUT" ] && rm $MAININPUT

			exit 0
		fi


	        # make decision
	        case $menuitem in
			1) client_mgmt_menu;;
			2) group_mgmt_menu;;
	                3) report_menu;;
	                4) yasa_mgmt_menu;;
	                Exit) echo "Bye"; break;;
	        esac
	done
fi
	
[ -f "$MAININPUT" ] && rm $MAININPUT 

exit 0
