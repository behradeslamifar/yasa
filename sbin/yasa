#!/bin/bash

# This script is based on IOI organization request for control on USB connections 
# and devices. 
# Copyright (C) 2016 Behrad Eslamifar <b.eslamifar@cvak.ir> and IOI
# This is properitary software and cant freely distributed.
# Version number (may use later)
version=0.9.6
client_version=0.6
yasarepo_date="2017-05-21"

# Disable ctrl+c in program
trap "" SIGINT

# Load default configuration
source /etc/default/yasa

source /usr/lib/yasa/yasa-functions
source /usr/lib/yasa/yasa-tui

check_prerequire_config() {
	## This function check default need to run corrctly yasa

	# local variables
	local result

	# If yasa run as root user
	echo -n "Run as root user ... "
	if [ "$(id -u)" != "0" ]
	then
		echo -e "\e[91mfail\e[0m"
		return 1
	fi
	echo -e "\e[92mpass\e[0m"

	# check puppetmaster is installed
	echo -en "Dependency check \"Puppet Master\" ... "

	result=$(dpkg -l puppetmaster 2> /dev/null | grep "^ii")
	if [ -z "$result" ]
	then
		echo -e "\e[91mfail\e[0m"
		return 2
	fi
	echo -e "\e[92mpass\e[0m"

	# sed
	echo -en "Dependency check \"sed\" ... "

	result=$(dpkg -l sed | grep "^ii")
	if [ -z "$result" ]
	then
		echo -e "\e[91mfail\e[0m"
		return 3
	fi
	echo -e "\e[92mpass\e[0m"

	# dialog
	echo -en "Dependency check \"dialog\" ... "

	result=$(dpkg -l dialog | grep "^ii")
	if [ -z "$result" ]
	then
		echo -e "\e[91mfail\e[0m"
		return 4
	fi
	echo -e "\e[92mpass\e[0m"


	# check yasa module linked to yasa config folder
	echo -en "Yasa module installation ... "
	if /bin/false
	    #[ "$(readlink /etc/puppet/modules/yasa)" != "/etc/yasa/puppet" ]
	then
		echo -e "\e[91mfail\e[0m"
		return 5
	fi
	echo -e "\e[92mpass\e[0m"
}

log_to_file() {
	# local variables
	local msg=$*
	local date=$(date +"%Y-%m-%d %H:%m:%S.%s%Z")
	local message="$date $msg"

	echo "$message" >> $YASA_ADMIN_LOG

	return 0
}

log_main() {
	## This is main log function. Each message have this structure
	##	[ msg_code ] hostid groupid deviceid class message
	## If one item is missing, placeholder is "-"
	## Message code:
	##	100 add host
	##	101 delete host
	##	102 enable host
	##	103 disable host
	##	104 signing host failed
	## 	105 singing host successful
	##	106 failed deploy
	##	107 success deploy
	##	110 add device to host
	##	111 delete device to host
	##	120 add class to host
	##	121 delete class from host
	##	200 add group
	##	201 delete group
	##	210 add device to group	
	##	211 delete device from group
	##	220 add class to group
	##	221 delete class from group
	##	230 add host to group
	##	231 delete host from group
	
	# local variables
	local msg_code=$1
	local hostid=$2
	local groupid=$3
	local deviceid=$4
	local class=$5
	shift 5
	local msg=$*

	case $msg_code in 
		100) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	101) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	102) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	103) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	104) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	105) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	106) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	107) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	110) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	111) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	120) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	121) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	200) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	201) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	210) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;	
        	211) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	220) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	221) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	230) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
        	231) log_to_file $msg_code $hostid $groupid $deviceid $class $msg ;;
	esac
	
	return 0
}

modify_class() { 
	## This function create iWCLASS (class.allow) file for host and for group, both.
	## $1 -> host,group , $2 -> hostid,groupid 
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# local variable
	# $1 -> host,group , $2 -> hostid,groupid
	local type=$1
	local id=$2
	local classid
	local home
	local backtitle

	# set home
	if [ "$type" == "host" ]
	then
		home=$CLIENTHOME
		backtitle="Client Management"
	else
		home=$GRPHOME
		backtitle="Group Management"
	fi

	# choose between usb class
        /usr/bin/dialog --backtitle "$backtitle" \
        --title "[ List of USB Class ]" \
        --checklist "Choose a class to add to whitelist" 13 60 22 \
	00h "Use class information in the Interface Descriptors" $(class_existence_check $type $id 00) \
	01h "Audio" $(class_existence_check $type $id 01) \
	02h "Communications and CDC Control" $(class_existence_check $type $id 02) \
	03h "HID (Human Interface Device)" $(class_existence_check $type $id 03) \
	05h "Physical" $(class_existence_check $type $id 05) \
	06h "Image" $(class_existence_check $type $id 06) \
	07h "Printer" $(class_existence_check $type $id 07) \
	08h "Mass Storage" $(class_existence_check $type $id 08) \
	09h "Hub" $(class_existence_check $type $id 09) \
	0Ah "CDC-Data" $(class_existence_check $type $id 0A) \
	0Bh "Smart Card" $(class_existence_check $type $id 0B) \
	0Dh "Content Security" $(class_existence_check $type $id 0D) \
	0Eh "Video" $(class_existence_check $type $id 0E) \
	0Fh "Personal Healthcare" $(class_existence_check $type $id 0F) \
	10h "Audio/Video Devices" $(class_existence_check $type $id 10) \
	11h "Billboard Device Class" $(class_existence_check $type $id 11) \
	12h "USB Type-C Bridge Class" $(class_existence_check $type $id 12) \
	DCh "Diagnostic Device" $(class_existence_check $type $id DC) \
	E0h "Wireless Controller" $(class_existence_check $type $id E0) \
	EFh "Miscellaneous" $(class_existence_check $type $id EF) \
	FEh "Application Specific" $(class_existence_check $type $id FE) \
	FFh "Vendor Specific" $(class_existence_check $type $id FF) 2> $output

	# save dialog state (find if user press cancel)
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$output" ] && rm $output
	
		return 1
	fi

	# start with fresh class file
	echo "" > $home/$id/temp/$WCLASS

	for classid in $(<$output)
	do
		classid=$(echo $classid | tr -d 'h')
		echo $classid >> $home/$id/temp/$WCLASS 	
	
		# log modify host/group
		if [ "$type" == "host" ]
		then
			log_main 120 $id - - - Classid $classid add to $id rules.
		else
			log_main 220 - $id - - Classid $classid add to $id rules.
		fi
	done

	# create udev rule file
	if [ "$type" == "group" ] 
	then
		group_udev_gen $id
	elif [ "$type" == "host" ] 
	then
		host_write_rule $id
	fi
	

	# remove temp file
	[ -f "$output" ] && rm $output

	return 0

}

modify_add_dev() {
	## This function create WDEVICE (dev.allow) file for host and for group, both.
	## $1 -> host,group , $2 -> hostid,groupid 
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local normal_log1=$(mktemp /tmp/usb.XXXXXXX)
	local normal_log2=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM
	trap "rm $normal_log1; exit" SIGHUP SIGINT SIGTERM
	trap "rm $normal_log2; exit" SIGHUP SIGINT SIGTERM

	# local variable
	# $1 -> host,group , $2 -> hostid,groupid
	local type=$1
	local id=$2
	local home
	local log_line_number
	local validtime
	local currenttime
	local exist
	local comment

	# define local array
	local log_line_array=()
	local log_line=()


	# set home
	if [ "$type" == "host" ]
	then
		home=$CLIENTHOME
		backtitle="Client Management"
	else
		home=$GRPHOME
		backtitle="Group Management"
	fi
	
	# loop for find device information from Yasa log
	while true
	do
	    # search based on ip address
	    dialog --backtitle "$backtitle" --inputbox "Please search the keywork to find your device (ip|hostname|device)" 8 80 2> $output

	    # save dialog state (find if user press cancel)
	    response=$?

	    # save input variable
	    keyword=$(<$output)

	    # if user cancel the dialog or press escape 
	    if [ "$response" == "1" -o "$response" == "255" ]
	    then
	    	[ -f "$output" ] && rm $output
	    	[ -f "$normal_log1" ] && rm $normal_log1
	    	[ -f "$normal_log2" ] && rm $normal_log2
	    
	    	return 1
	    fi

	    # normalize log file
	    cat $DEVICELOG | grep -i "$keyword" | tail | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' > "$normal_log1"

	    if [ ! -z "$(<$normal_log1)" ]
	    then
		break
	    fi
	done

	# second step normalize log file
	cat "$normal_log1" | cut -f 1,3,5,6,7,8 -d " " > "$normal_log2"

	while read n s ; do
	    log_line_array+=($n "$s")
	done < $normal_log2

	dialog  --backtitle "$backtitle" --title "Founded devices" --menu "Your choozen device will be add to whitelist" 0 80 10 "${log_line_array[@]}" 2> $output

	# get reponse
	response=$?

	# get data stored in $output
	log_line_number=$(<$output)
	
	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp files
	    	[ -f "$output" ] && rm $output
	    	[ -f "$normal_log1" ] && rm $normal_log1
	    	[ -f "$normal_log2" ] && rm $normal_log2
	
		return 1
	fi

	# pick log line
	log_line=($(sed -n "$log_line_number p" $normal_log2))

	# check if device added befor
	device_existence_check $type $id ${log_line[1]#*:} ${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:} && dialog --backtitle "$backtitle" --msgbox "Device already exist in whitelist" 5 38 && exist=1

	# input comment
	if [ "$exist" != "1" ]
	then
		dialog --backtitle "$backtitle" --inputbox "Write comment for this device" 8 80 "no comment" 2> $output

		# get response
		response=$?

		comment=$(<$output)


		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp files
			[ -f "$output" ] && rm $output
		    	[ -f "$normal_log1" ] && rm $normal_log1
		    	[ -f "$normal_log2" ] && rm $normal_log2

			return 1
		fi

		# input box for enter validation time in houre
		while true
		do
			dialog --backtitle "$backtitle" --inputbox "Please enter validation time in houre (enter 0 or leave blank for unlimite time)" 8 80 0 2> $output

			# get response
			response=$?

			validtime=$(<$output)


			# if user cancel the dialog or press escape 
			if [ "$response" == "1" -o "$response" == "255" ]
			then 
				# remove temp files
				[ -f "$output" ] && rm $output
				[ -f "$normal_log1" ] && rm $normal_log1
				[ -f "$normal_log2" ] && rm $normal_log2
		
				return 1
			fi

			if [ "$validtime" = "0" ]
			then
				break
			elif [ ! -z "$(echo $validtime | grep '^[1-9][0-9]*$')" ]
			then
				currenttime=$(date +"%s")
				validtime=$(( $validtime * 60 * 60 + $currenttime ))
				break
			fi
		done


		# add new device to white list
		echo -e "# comment $comment \n# ${log_line[1]} ${log_line[2] } \n$validtime ${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:}\n" >> $home/$id/temp/$WDEVICE

		
		log_main 110 $id - - - The $hostid added successfully

		# create udev rule file
		host_write_rule $id
	fi
		
	# remove temp file if exist
	[ -f "$output" ] && rm $output
	[ -f "$normal_log1" ] && rm $normal_log1
	[ -f "$normal_log2" ] && rm $normal_log2
	
	return 0
}

modify_del_dev() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# define array
	local ar=()

	# local variable
	# $1 -> host,group , $2 -> hostid,groupid
	local type=$1
	local id=$2
	local home
	local backtitle
	local device
	local count
	local comment
	local linenum=0
	local line

	# set home
	if [ "$type" == "host" ]
	then
		home=$CLIENTHOME
		backtitle="Client Management"
	else
		home=$GRPHOME
		backtitle="Group Management"
	fi
	
	while read line 
	do
	        if [ ! -z "$(echo $line | grep "^# comment" )" ]
	        then
			((linenum++))
	                comment=$line; count=1;
	                continue
	        elif [ "$count" = "1" ] && [ ! -z "$(echo $line | grep "^# From")" ]
	        then
	                device=$(echo $line | grep -o "Device:.*$")
	                ar+=($linenum "$comment $device")
	                count=0
	        fi
	done <$home/$id/temp/$WDEVICE	
	
	if [ -z "${ar[@]}" ]
	then
		dialog --backtitle "$backtitle" --msgbox "There isnt any device in whitelist" 5 40
		# remove temp file
		[ -f "$output" ] && rm $output
	
		return 0
	fi

	dialog  --backtitle "$backtitle" --title "List of white list" --menu "Choose one for delete from whitelist" 10 80 5 "${ar[@]}" 2> $output
	
	# save menu output
	local devicenum=$(<$output)

	if [ ! -z "$devicenum" ]
	then
		echo "" > $output
		linenum=0
	
		while read line
		do
			if [ ! -z "$(echo $line | grep "^# comment")" ]
			then
				ucomment=$line
				((linenum++))
			elif [ ! -z "$(echo $line | grep "^# From:")" ]
			then
				scomment=$line
			elif [ ! -z "$(echo $line | grep "^[0-9]" )" ]
			then
				if  [ "$linenum" != "$devicenum" ]
				then
					echo -e "$ucomment\n$scomment\n$line" >> $output
				fi
			else
				echo $line >> $output
			fi
		done < $home/$id/temp/$WDEVICE
	
	 	cat -s $output > $home/$id/temp/$WDEVICE	
		dialog --backtitle "$backtitle" --msgbox "Device deleted from whitelist" 5 35

		# create udev rule file
		[ "$type" == "host" ] && host_write_rule $id
	fi

	# remove temp file
	[ -f "$output" ] && rm $output
	
	return 0
}

group_modify_dev() {
	# local variables
	local validtime=0
	local currenttime
	local groupid=$1
	local keyword
	local response
	local log_line_number

	# define local array
	local log_line_array=()
	local log_line=()

	# temperorly file 
	local INPUT1=$(mktemp /tmp/usb.XXXXXXXX)
	local INPUT2=$(mktemp /tmp/usb.XXXXXXXX)
	
	# menu output
	local output=$(mktemp /tmp/output.XXXXXXX)

	# trap and delete temp file
	trap "rm $INPUT1 $INPUT2 $output; exit" SIGHUP SIGINT SIGTERM
	
	while true
	do
	    # search based on ip address
	    dialog --inputbox "Please search the keywork to find your device (ip|hostname|device)" 8 80 2> $output

	    # save dialog state (find if user press cancel)
	    response=$?

	    # save input variable
	    keyword=$(<$output)

	    # if user cancel the dialog or press escape 
	    if [ "$response" == "1" -o "$response" == "255" ]
	    then
	    	[ -f "$INPUT1" ] && rm $INPUT1
	    	[ -f "$INPUT2" ] && rm $INPUT2
	    	[ -f "$output" ] && rm $output
	    
	    	return 1
	    fi

	    # normalize log file
	    cat $DEVICELOG | grep -i "$keyword" | tail | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' > "$INPUT2"

	    if [ ! -z "$(<$INPUT2)" ]
	    then
		break
	    fi
	done

	cat "$INPUT2" | cut -f 1,3,5,6,7,8 -d " " > "$INPUT1"

	while read n s ; do
	    log_line_array+=($n "$s")
	done < $INPUT1

	dialog  --title "Founded devices" --menu "Your choozen device will be add to whitelist" 0 80 10 "${log_line_array[@]}" 2> $output

	# get reponse
	response=$?

	# get data stored in $output
	log_line_number=$(<$output)
	
	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$output" ] && rm $output

		return 1
	fi

	# pick log line
	log_line=($(sed -n "$log_line_number p" $INPUT1))

	# check if device added befor
	device_existence_check group $groupid ${log_line[1]#*:} ${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:} && dialog --msgbox "Device already exist in whitelist" 5 38 && return 1

	# input comment
	dialog --inputbox "Write comment for this device" 8 80 "no comment" 2> $output

	# get response
	response=$?
	
	local comment=$(<$output)


	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp files
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$output" ] && rm $output

		return 1
	fi

	# input box for enter validation time in houre
	while true
	do
		dialog --inputbox "Please enter validation time in houre (enter 0 or leave blank for unlimite time)" 8 80 0 2> $output

		# get response
		response=$?

		validtime=$(<$output)

		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp files
			[ -f "$INPUT1" ] && rm $INPUT1
			[ -f "$INPUT2" ] && rm $INPUT2
			[ -f "$output" ] && rm $output
	
			return 1
		fi

		if [ "$validtime" = "0" ]
		then
			break
		elif [ ! -z "$(echo $validtime | grep '^[1-9][0-9]*$')" ]
		then
			currenttime=$(date +"%s")
			validtime=$(( $validtime * 60 * 60 + $currenttime ))
			break
		fi
	done


	# add new device to white list
	echo -e "# comment $comment \n# ${log_line[1]} ${log_line[2] } \n${log_line[3]#*:} ${log_line[4]#*:} ${log_line[5]#*:}\n" >> $GRPHOME/$groupid/temp/$WDEVICE
		
	# remove temp file if exist
	[ -f "$INPUT1" ] && rm $INPUT1
	[ -f "$INPUT2" ] && rm $INPUT2
	[ -f "$output" ] && rm $output
	
	return 0
}


group_modify_rule() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM


        # count number of host
        local groupsum=$(ls $GRPHOME | wc -l)
	

	if [ -z "$1" ]
	then
		local interactive=1
	else
		local interactive=0
		local groupid=$1
	fi

	while true
	do
	   if [ "$interactive" == "1" ]
	   then
		# choose group to modify
		dialog --title "Group List" --menu "Choose one group to modify" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $output
	
		# get response
		response=$?

		# save dialog output in variable
		local groupid=$(<$output)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$output" ] && rm $output
			
			return 0
		fi
	
	   fi
	   
	   # modify class
	   modify_class group $groupid

	   # if press cancel remove group folder
	   response=$?

	   if [ "$response" == "1" ]
	   then
	   	[ -f "$output" ] && rm $output
	   	return 1
	   fi

	   # Modify device whitelist
	   while true
	   do
	   	if [ "$interactive" == "1" ]
	   	then
	   	     # choose add or delete device
	   	     dialog --backtitle "Group Management" --title "[ G R O U P - M O D I F Y ]" \
	   	     --menu "Choose what you want to do.\n\
	   	     Press cancel to exit from this menu." 12 60 3 \
	   	     1 "Add Device" \
	   	     2 "Delete Device" \
	   	     3 "Dont Add Device" 2>"${output}"
	
	   	     # get response
	   	     response=$?

	   	     # if user enter cancel or press esc
	   	     if [ "$response" == "1" -o "$response" == "255" ]
	   	     then
	   	             # remove temp file
	   	             [ -f "$output" ] && rm $output

	   	     	return 0
	   	     fi

	   	     # make decision
	   	     case $(<$output) in
	   	     	1) modify_add_dev group $groupid;;
	   	     	2) modify_del_dev group $groupid;;
			3) echo "Do nothing" > /dev/null ;;
	   	     esac

		     	##bug
	   		# if press cancel remove group folder
	   		response=$?

	   		if [ "$response" == "1" ]
	   		then
	   			break
	   		fi
		else
		    dialog --backtitle "Group Management" --title " Add Device " --yesno "Do you add device to whitelist?" 6 50

		    # get response
		    response=$?

		    if [ "$response" == "0" ]
		    then
			modify_add_dev group $groupid
			
			# if press cancel remove group folder
			response=$?

			if [ "$response" == "1" ]
			then
			    [ -f "$output" ] && rm $output
			    return 1
			fi
		    else
			break
		    fi
	   	fi
	
		# add another device
		dialog --backtitle "Group Management" --title " Another Device " --yesno "Do you add another device to whitelist?" 6 50
		
		# get response
		response=$?

		if [ "$response" == "0" ]
		then
			continue
		else
			break
		fi
	   done

	   # create udev rule
	   group_udev_gen $groupid

	   # if press cancel remove group folder
	   response=$?

	   if [ "$response" == "1" ]
	   then
	   	[ -f "$output" ] && rm $output
	   	return 1
	   fi

	   # break while if noninteractive
           if [ "$interactive" == "0" ]
           then
		break
	   fi
 
	done

        # remove temp file
        [ -f "$output" ] && rm $output

        return 0

}

group_modify_members() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local oldmemberlist=$(mktemp /tmp/usb.XXXXXXX)
	local failedhost=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output $oldmemberlist; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local groupid
	local hostid
	local groupsum
	local hostsum
	local groupfilepath
	local response

	# if function had argument
	if [ ! -z "$1"	]
	then
		groupid="$1"
	else
	        # count number of group
	        groupsum=$(ls $GRPHOME | wc -l)
	
		# if no any group 
		if [ "$groupsum" == "0" ] 
		then
			dialog --backtitle "Group Management" --title "Modify Group" --msgbox "No Groups" 6 30
	
			return 1
		fi

	        # choose group to modify
	        dialog --title "Group List" --menu "Choose one group to add/remove member" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $output
	
	        local groupid=$(<$output)
	
	        # if user select cancel
	        if [ -z "$groupid" ]
	        then
	                # remove temp file
	                [ -f "$output" ] && rm $output
		        [ -f "$oldmemberlist" ] && rm $oldmemberlist
	
	                return 1
	        fi
	fi

	hostsum=$(ls $CLIENHOME | wc -l)

        # choose hosts to add to group
        dialog --title "Choose host(s)" --checklist "Choose one/more host(s) for add to group" 10 60 $hostsum $(for i in $(ls $CLIENTHOME/); do echo "$i ${i%%.*} $(group_find_member $groupid $i) " | tr -d "\n"; done) 2> $output

	# get response
	response=$?

        # if user press cancel
        if [ "$response" == "1" -o "$response" == "255" ]
        then
                # remove temp file
                [ -f "$output" ] && rm $output
        	[ -f "$oldmemberlist" ] && rm $oldmemberlist

                return 1
        fi

	# remove all old member
	find $CLIENTHOME -type f -name "grp.$groupid" -exec sh -c "echo -n '{} ' >> $oldmemberlist" \;

	[ ! -z "$(<$output)" ] && for hostid in $(<$output)
	do
		rm $CLIENTHOME/$hostid/temp/grp.* 2> /dev/null
		touch $CLIENTHOME/$hostid/temp/grp.$groupid

		# remove from old list
		groupfilepath=$CLIENTHOME/$hostid/temp/grp.$groupid
		sed -i 's_'"$groupfilepath"'__' $oldmemberlist

		[ ! -z "$hostid" ] && host_write_rule $hostid
	done

	[ ! -z "$(<$output)" ] && for hostid in $(<$output)
	do
		if [ ! -z "$hostid" ] 
		then
			host_deploy_config $hostid silent >> $failedhost                                                                         
		fi
	done

	# Remove old member from group
	[ ! -z "$(<$oldmemberlist)" ] && for I in $(<$oldmemberlist)
	do
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		rm -r $CLIENTHOME/$hostid/temp/grp.* 2> /dev/null
		[ ! -z "$hostid" ] && host_write_rule $hostid
	done

	# Deploy new config for removed member
	for I in $(<$oldmemberlist)
	do
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		if [ ! -z "$hostid" ] 
		then
			host_deploy_config $hostid silent >> $failedhost
		fi
	done

        if [ -z "$(<$failedhost)" ]    
        then
                echo "Client configuration deployment Process successfuly done." > $failedhost
                dialog --backtitle "Group Management" --title "Client Deployment" --textbox $failedhost 10 80
        else
                dialog --backtitle "Group Management" --title "Failed Host(s)" --textbox $failedhost 10 80
        fi


        # remove temp file
        [ -f "$output" ] && rm $output
        [ -f "$oldmemberlist" ] && rm $oldmemberlist

        return 0
		
       for hostid in $(<$output)       
        do
            if [ "$hostid" == all ]        
            then              
                for hostid in $(ls $CLIENTHOME)
                do            
                    host_write_rule $hostid        
                    host_deploy_config $hostid silent >> $failedhost                                                                         
                done
                break         
            fi
            host_write_rule $hostid        
            host_deploy_config $hostid silent >> $failedhost                                                                                 
        done

	return 0
}

group_modify() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# group name variable
	local groupid
	local groupsum

	# show list of groups
	# count number of group
	groupsum=$(ls $GRPHOME | wc -l)
	
	# if no any group 
	if [ "$groupsum" == "0" ] 
	then
		dialog --backtitle "Group Management" --title "Modify Group" --msgbox "No Groups" 6 30

		return 1
	fi

        ## choose group to modify
        #dialog --backtitle "Group Management" --title "Group List" --menu "Choose one group to modify" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $output

	## get response
	#response=$?

	## save dialog output in variable
	#groupid=$(<$output)
	#
	## if user cancel the dialog or press escape 
	#if [ "$response" == "1" -o "$response" == "255" ]
	#then 
	#	# remove temp file
	#	[ -f "$output" ] && rm $output
	#	
	#	return 1
	#fi
	
	# modify group
	group_modify_rule 

	# if press cancel remove group folder
	response=$?

	#if [ "$response" == "1" ]
	#then
	#	[ ! -z "$groupid" ] && rm -r $GRPHOME/$groupid
	#	[ -f "$output" ] && rm $output
	#	return 1
	#fi

	## modify member
	#group_modify_members $groupid

	## if press cancel remove group folder
	#response=$?

	#if [ "$response" == "1" ]
	#then
	#	rm -r $GRPHOME/$groupid
	#	[ -f "$output" ] && rm $output
	#	return 1
	#fi

	# remove temp file
	[ -f "$output" ] && rm $output
				
	return 0
}

group_add() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# group name variable
	local groupid
	local grouphome
	local response
	
	while true
	do
		dialog --inputbox "Enter name of new group\nName must be 3 character at least\nOnly use Lowercase Alphabet and Digits" 10 50 2> $output

		# get response
		response=$?

		# save dialog output in variable
		groupid=$(<$output)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$output" ] && rm $output
			
			return 1
		fi
	
		# validate group name 
		if [ -z "$(echo "$groupid" | egrep "[a-z0-9]{3,}")" ] 
		then
			dialog --msgbox "Group name not accepted, please use valid format." 6 60
		elif [ ! -z "$(ls $GRPHOME | grep "^${groupid}$")" ]
	        then
	                dialog --msgbox "This Group already exists.\nPlease choose another name or use\nmodify group menu for add member" 7 40
		else 
			mkdir $GRPHOME/$groupid
			cp -ar $TEMPHOME/group/* $GRPHOME/$groupid
			grouphome=$GRPHOME/$groupid
		
			break
		fi
	done

	# modify group
	group_modify_rule $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $grouphome
		dialog --backtitle "Group Management" --title " Adding Group Failed "  --msgbox "Adding group failed during error or user cancelation." 6 70

		[ -f "$output" ] && rm $output
		return 1
	fi

	# modify member
	group_modify_members $groupid

	# if press cancel remove group folder
	response=$?

	if [ "$response" == "1" ]
	then
		rm -r $GRPHOME/$groupid
		dialog --backtitle "Group Management" --title " Adding Group Failed "  --msgbox "Adding group failed during error or user cancelation." 6 70

		[ -f "$output" ] && rm $output
		return 1
	fi

	dialog --backtitle "Group Management" --msgbox "Group added successfully." 6 70

	log_main 200 - $groupid - - The $groupid group added successfully

	# remove temp file
	[ -f "$output" ] && rm $output
				
	return 0
}

group_del() {
	# wish list
	# featur 1: add soft delete
	# temp variables
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local oldmemberlist=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output $oldmemberlist; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local groupid
	local hostid
	local groupsum
	local response

	# choose group from list
	# if function had argument
	if [ ! -z "$1"	]
	then
		groupid="$1"
	else
	        # count number of group
	        groupsum=$(ls $GRPHOME | wc -l)
	
		# back to ment if not any group
		if [ "$groupsum" == "0" ]
		then
			echo "Not any group exist yet." > $output
			dialog --backtitle "Group Management" --title "Delete Group Memeber(s)" --textbox $output 5 50

			# remove temp file
			[ -f "$output" ] && rm $output
        		[ -f "$oldmemberlist" ] && rm $oldmemberlist

			return 1
		fi

	        # choose group to modify
	        dialog --backtitle "Group Management" --title "Group List" --menu "Choose one group to add/remove member" 10 60 $groupsum $(for i in $(ls $GRPHOME/); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $output
	
		# get response
		response=$?

	        local groupid=$(<$output)
	
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" -o "$response" == "255" ]
		then 
			# remove temp file
			[ -f "$output" ] && rm $output
        		[ -f "$oldmemberlist" ] && rm $oldmemberlist
			
			return 1
		fi

	fi

	# are you sure
	dialog --backtitle "Group Management" --title " Warning " --yesno "Do you realy want to delete?\nThis task cant recover after progress" 6 50

	# get response
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$output" ] && rm $output
        	[ -f "$oldmemberlist" ] && rm $oldmemberlist
		
		return 1
	fi

	# remove member from group (progress 25%)
	echo 25 | dialog --backtitle "Group Management" --gauge "Remove $groupid members" 7 70 0
	find $CLIENTHOME -type f -name "grp.$groupid" -exec sh -c "echo -n '{} ' >> $oldmemberlist" \;
	for I in $(<$oldmemberlist)
	do
		rm -r $I
	done
	sleep 1
	
	# add default host rule to hosts (progress 50%)
	echo 50 | dialog --backtitle "Group Management" --gauge "Recovering hosts rules" 7 70 0
	for I in $(<$oldmemberlist)
	do
		
		hostid=$(echo $I |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		[ ! -z "$hostid"] && host_write_rule $hostid
	done
	sleep 1


	# deploy rule to removed host (progress 75%)
	echo 75 | dialog --backtitle "Group Management" --gauge "Deploy new rule to hosts" 7 70 0
	for I in $(<$oldmemberlist)
	do
		hostid=$(echo $i |  sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_")
		[ ! -z "$hostid" ] && host_deploy_config $hostid
	done
	sleep 1

	# remove group folder (progress 90%)
	echo 90 | dialog --backtitle "Group Management" --gauge "Remove $groupid files" 7 70 0
	rm -r $GRPHOME/$groupid
	sleep 1

	# progress 100%
	echo 100 | dialog --backtitle "Group Management" --gauge "Remove $groupid files" 7 70 0
	sleep 1

	dialog --msgbox "$groupid removed successfuly" 6 45

	log_main 201 - $groupid - - The $groupid group removed successfully

        # remove temp file
        [ -f "$output" ] && rm $output
        [ -f "$oldmemberlist" ] && rm $oldmemberlist

        return 0
	
}

whitelist_show() {
	# temp file for menu output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# local variable
	local type=$1
	local id=$2
	local response
	local idsum
	local backtitle
	local groupid

	# set home
	if [ "$type" == "host" ]
	then
		home=$CLIENTHOME
		backtitle="Client Management"
	else
		home=$GRPHOME
		backtitle="Group Management"
	fi

	while true
	do
		# show list of groups
	        # count number of group
	        idsum=$(ls $home | wc -l)
		
		# if no groups
		if [ "$idsum" == "0" ] 
		then
			[ "$type" == "host" ] && dialog --backtitle "$backtitle" --title "$backtitle" --msgbox "No hosts" 6 30
			[ "$type" == "group" ] && dialog --backtitle "$backtitle" --title "$backtitle" --msgbox "No Groups" 6 30

			return 0
		fi

	        # choose host or group to show
	        dialog --backtitle "$backtitle" --title "List" --menu "Choose one options. Press cancel to exit and Esc to start again" 10 60 $idsum $(for i in $(ls $home/); do echo "$i $i " | tr -d "\n"; done) 2> $output
	
		# get response
		response=$?

	        local id=$(<$output)
		
		# if user cancel the dialog or press escape 
		if [ "$response" == "1" ]
		then 
			# remove temp file
			[ -f "$output" ] && rm $output
			
			return 1
		elif [ "$response" == "255" ] 
		then 
			continue
		fi

		if [ "$type" == "host" ]
		then
			# check that not in any group
			host_is_it_member $id

			# get response                 
			response=$?                    
			
			if [ "$response" == "0" ]      
			then                           
			        groupid=$(host_is_it_member $id)
			        dialog --backtitle "Client Management" --msgbox "$id is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55   
			
			        # remove temp file if exist    
			        [ -f "$output" ] && rm $output
			
			        return 1                       
			
			fi 
		fi

		# show member in text box
		if [ "$type" == "group" ]
		then
			find $CLIENTHOME -name "grp.$id" | sed "s_$CLIENTHOME/\(.*\)/temp/grp.*_\1_" > $output
			dialog --backtitle "Group Management" --title "Group Member(s)" --textbox $output 10 80

			if [ "$response" == "255" ]
			then
				continue
			fi
		fi

		# show class
		# Convert to human readable text
		sed -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/00/00h Use class information in the Interface Descriptors/' \
		        -e 's/01/01h Audio/' \
		        -e 's/02/02h Communications and CDC Control/' \
		        -e 's/03/03h HID (Human Interface Device)/' \
		        -e 's/05/05h Physical/' \
		        -e 's/06/06h Image/' \
		        -e 's/07/07h Printer/' \
		        -e 's/08/08h Mass Storage/' \
		        -e 's/09/09h Hub/' \
		        -e 's/0A/0Ah CDC-Data/' \
		        -e 's/0B/0Bh Smart Card/' \
		        -e 's/0D/0Dh Content Security/' \
		        -e 's/0E/0Eh Video/' \
		        -e 's/0F/0Fh Personal Healthcare/' \
		        -e 's/10/10h Audio\/Video Devices/' \
		        -e 's/11/11h Billboard Device Class/' \
		        -e 's/12/12h USB Type-C Bridge Class/' \
		        -e 's/DC/DCh Diagnostic Device/' \
		        -e 's/E0/E0h Wireless Controller/' \
		        -e 's/EF/EFh Miscellaneous/' \
		        -e 's/FF/FEh Application Specific/' \
		        -e 's/FF/FFh Vendor Specific/'  $home/$id/temp/$WCLASS | \
							grep -v "^$" > $output
		if [ -z "$(<$output)" ]
		then
			echo "There is not exist any class in white list" > $output
		fi
		dialog --backtitle "Group Management" --title "Whitelist Class" --textbox $output 10 80

		# get response
		response=$?

		if  [ "$response" == "255" ]
		then
			continue
		fi
	
		# show device rule
		# change unix time to normal time
		sed 's|\(^[1-9][0-9]*\)\( .*\)|date --date=@\1 +%Y/%m/%d-%H:%M"\2"|e' $home/$id/temp/$WDEVICE | cat -s > $output
		if [ -z "$(<$output)" ]
		then
			echo "There is not exist any device in white list" > $output
		fi

		dialog --backtitle "$backtitle" --title "White List Device(s)" --textbox $output 10 80

		# get response
		response=$?

		if [ "$response" == "1" ]
		then
			break
		elif [ "$response" == "255" ]
		then
			continue
		fi

	done

	# remove temp file
	[ -f "$output" ] && rm $output
				
	return 0

}

# Host Management Functions
host_puppet_entry() {
	## This is function is only find hostname from puppet cert list and back 
	## it to host_add function.
	## It not run validation or not save anything.

	local __hostid
	local __hostidvar=$1
	local response
	local output=$(mktemp /tmp/output.XXXXXXX) 

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# progress bar till calculate host number
	echo 30 | dialog --backtitle "Client Management" --gauge "Calculate number of ready hosts ..." 7 70 0
	##test
        local hostsum=$(puppet cert list --all | wc -l)

	# check if any hostname wait for sign
        if [ "$hostsum" == "0" ]       
        then
                echo "Not any client exist in waiting list" > $output
                dialog --backtitle "Client Management" --title "Accept New Client" --textbox $output 5 50

		# remove temp file
                [ -f "$output" ] && rm $output

                return 1      
        fi

	# progress bar till find hostnames
	echo 70 | dialog --backtitle "Client Management" --gauge "Wait till hostnames list be ready ..." 7 70 0

	##test
        dialog --backtitle "Client Management" --title "Choose host" --menu "Choose one host to sign and add to Yasa" 10 60 $hostsum $(for i in $(puppet cert list --all | tr -s ' ' | sed 's/^\(+ \| \)\"/\"/' | cut -f 1 -d " " | tr -d '"'); do echo "$i ${i%%.*} " | tr -d "\n"; done) 2> $output

	# get reponse
	response=$?

	# get hostid
	__hostid=$(<$output)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" -o -z "$(<$output)" ]
	then 
		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi

	# set hostid variable for output
	eval "$__hostidvar"="'$__hostid'"

	# remove temp file
	[ -f "$output" ] && rm $output
	
	return 0
}

host_log_entry() {
	local validtime=0
	local currenttime
	local keyword
	local response
	local __hostidvar=$1
	local __hostid

	# temperorly file 
	local INPUT1=$(mktemp /tmp/usb.XXXXXXXX)
	local INPUT2=$(mktemp /tmp/usb.XXXXXXXX)
	
	# menu output
	local OUTPUT=$(mktemp /tmp/output.XXXXXXX)

	# define local array
	local ar=()
	local newwhite=()

	# trap and delete temp file
	trap "rm $INPUT1 $INPUT2 $OUTPUT; exit" SIGHUP SIGINT SIGTERM
	

	# search based on keyword
	dialog --backtitle "Client Management" --title "S E A R C H B O X" --inputbox "Please enter keyword to search in Yasa log file" 8 70 2> $OUTPUT

	# get response
	reponse=$?

	# save input variable
	keyword=$(<$OUTPUT)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT
		
		return 1
	fi
	
	# check that DEVICELOG not to be empty
	if [ ! -s "$DEVICELOG" ] 
	then
	    logger -s "Device log was empty"
	    dialog --backtitle "Client Management" --title "Error Message" --msgbox "Device log was empty." 6 60

	    # remove temp file
	    [ -f "$INPUT1" ] && rm $INPUT1
	    [ -f "$INPUT2" ] && rm $INPUT2
	    [ -f "$OUTPUT" ] && rm $OUTPUT
	    
	    return 1
	fi

	cat $DEVICELOG | grep -i "$keyword" | tail | tac | cat -n | expand  | tr -s ' ' | sed 's/ //' >$INPUT2

	# check if search result is empty
	if [ ! -s "$INPUT2" ]
	then
	    logger -s "Not found any result"
	    dialog --backtitle "Client Management" --title "Error Message" --msgbox "Not found any result." 6 60

	    # remove temp file
	    [ -f "$INPUT1" ] && rm $INPUT1
	    [ -f "$INPUT2" ] && rm $INPUT2
	    [ -f "$OUTPUT" ] && rm $OUTPUT
	    
	    return 1
	fi

	cat "$INPUT2" | cut -f 1,3,5,6,7,8 -d " " > "$INPUT1"
	while read n s ; do
	    ar+=($n "$s")
	done < $INPUT1
	dialog  --title "Founded devices" --menu "Your choozen device will be add to whitelist" 0 80 10 "${ar[@]}" 2> $OUTPUT

	# get response
	reponse=$?

	NUM=$(<$OUTPUT)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$INPUT1" ] && rm $INPUT1
		[ -f "$INPUT2" ] && rm $INPUT2
		[ -f "$OUTPUT" ] && rm $OUTPUT
		
		return 1
	fi

	# pick log line
	newwhite=($(sed -n "$NUM p" $INPUT1))

	# get hostid
	__hostid=${newwhite[1]#*:}

	# send hostid to parent variable
	eval "$__hostidvar"="'$__hostid'"

	# remove temp files
	[ -f "$INPUT1" ] && rm $INPUT1
	[ -f "$INPUT2" ] && rm $INPUT2
	[ -f "$OUTPUT" ] && rm $OUTPUT
	
	return 0
}

host_manual_entry() {
	## This is function is only get hostname from user and pass it to host_add function
	## It not run validation or not save anything

	local __hostid
	local __hostidvar=$1
	local response
	local output=$(mktemp /tmp/output.XXXXXXX) 
	
	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# get hostid from user
	dialog --backtitle "Client Management" --title "I N P U T B O X" --inputbox "Please enter valid hostname." 8 70 2>"$output"

	# get reponse
	response=$?

	# get hostid
	__hostid=$(<$output)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi
	
	# set hostid variable for output
	eval "$__hostidvar"="'$__hostid'"

	# remove temp file
	[ -f "$output" ] && rm $output
	
	return 0
}
	
host_disable_yasa() {
	# Disable disable USB port in udev config. This function have many return value
	# 0 If all task done successfuly
	# 1 If host_deploy_config failed
	# 2 If found an error in pregeneration temp file

	local hostid=$1
	local response

	if [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "0" ]
	then
	    sed -i 's/devpath \(0\|1\)/devpath 1/' $CLIENTHOME/$hostid/temp/90-footer
	        echo "1" > $CLIENTHOME/$hostid/temp/$WDEF
	elif [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "1" ] 
	then
		echo "Do nothing" >/dev/null
	else
		dialog --backtitle "Client Management" --title "Error Message" --msgbox "Found an error in configuration files." 6 60
		return 2
	fi

	# generate udev config file
	host_write_rule $hostid
	
	# get response
	response=$?
	
	if [ "$response" == "1" ]
	then
		return 1
	fi		

	return 0
}

host_enable_yasa() {
	# Enable USB port in udev config. This function have many return value
	# 0 If all task done successfuly
	# 1 If host_deploy_config failed
	# 2 If found an error in pregeneration temp file

	local hostid=$1
	local response

	if [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "1" ]
	then
	    sed -i 's/devpath \(1\|0\)/devpath 0/' $CLIENTHOME/$hostid/temp/90-footer
	        echo "0" > $CLIENTHOME/$hostid/temp/$WDEF
	elif [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "0" ] 
	then
		echo "Do nothing" >/dev/null
	else
		dialog --backtitle "Client Management" --title "Error Message" --msgbox "Found an error in configuration files." 6 60
		return 2
	fi

	# generate udev config file
	host_write_rule $hostid

	# get response
	response=$?
	
	if [ "$response" == "1" ]
	then
		return 1
	fi		

	return 0
}

host_is_it_member() {
        local hostid="$1"     
        local membership=$(ls $CLIENTHOME/$hostid/temp/grp.* 2>/dev/null)

        if [ -z "$membership" ]        
        then
                return 1
        else
                echo ${membership##*.}         
                return 0      
        fi
}

host_sign() {
	## Check host is signing.

	# local variable
	local hostid=$1
	local response

	puppet cert sign $hostid

	# get response
	if [ "$response" == "24" ]
	then
		if [ ! -z  "$(puppet cert list --all | tr -s ' ' | sed 's/^\(+ \| \)\"/\"/' | cut -f 1 -d " " | tr -d '"' | grep "^${hostid}$")" ]
		then
			return 0
		else
			dialog --backtitle "Client Management" --msgbox "Could not find any request for \"$hostid\". Check client config."
			
			return 1
		fi

	fi

	return 0
}

host_sign_main() {
	# local variables
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local hostid
	
	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# collect client requests
	puppet cert list | tr -s ' ' | sed 's/^\(+ \| \)\"/\"/' | cut -f 1 -d " " | tr -d '"' > $output

	if [ -z "$(<$output)" ]
	then
		dialog --backtitle "Client Management" --msgbox "There isnt any request to sign." 5 60
	
		# remove temp file
		[ -f "$output" ] && rm $output

		return 0
	fi

	dialog  --backtitle "Client Management" --title "Clients Reqests List" --menu "Choose one to sign the client" 0 80 5 $(for i in $(<$output); do echo $i ${i%%.*}; done) 2> $output

	# get response
	response=$?

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp 	    	[ -f "$output" ] && rm $output
		[ -f "$output" ] && rm $output
		
		return 1
	fi
	
	hostid=$(<$output)

	host_sign $hostid
	
	# remove temp file
	[ -f "$output" ] && rm $output

	return 0
}

host_add() {
	# local variables
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local hostid
	local response
	local method
	local sign_response

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM
	
	while true
	do
	    # find host (from logs, cert list or manual)
	    dialog --backtitle "Client Management" --title "Choose Method" --menu "Choose a method to enter hostname\nPress cancel to return to Client Menu" 11 60 4 Puppet "Based puppet cert list" Log "Search hostname in logs" Manual "Enter hostname manualy" 2> $output

	    # get response
	    response=$?

	    # if user cancel the dialog or press escape 
	    if [ "$response" == "1" -o "$response" == "255" ]
	    then 
	    	# remove temp 	    	[ -f "$output" ] && rm $output
	    	[ -f "$output" ] && rm $output
	    	
	    	return 1
	    fi
	    
	    # get method
	    method=$(<$output)

	    # Puppet, Log or Manual
	    case $method in 
	    	Puppet) host_puppet_entry hostid ;;
	    	Log) host_log_entry hostid ;;
	    	Manual) host_manual_entry hostid ;;
	    esac
	   
	    if [ "$?" != "0" ]
	    then
		# remove temp file
	    	[ -f "$output" ] && rm $output
	    	
	    	return 1
	    fi

	    # hostid validation
	    if [ -z "$(echo "$hostid" | egrep "^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][a-zA-Z0-9_-]{1,61}[a-zA-Z0-9]))\.([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,})$")" ] 
	    then
	    	dialog --backtitle "Client Management" --title "Error Message" --msgbox "Entered hostname is invalid, please use valid format" 6 60

		# remove temp file
	    	[ -f "$output" ] && rm $output
	    	
	    	return 1
	    	
	    elif [ ! -z "$(ls $CLIENTHOME | grep "^$hostid$")" ]
	    then
	    	dialog --backtitle "Client Management" --title "Error Message"  --msgbox "This host is exists" 5 25
		# remove temp file
	    	[ -f "$output" ] && rm $output
	    	
	    	return 1
	    else

		# sign client
		echo 30 | dialog --backtitle "Client Management" --gauge "Signing $hostid ..." 7 70 0
		host_sign $hostid

		if [ "$?" != "0" ]
		then
			dialog --backtitle "Client Management" --title "Error Message"  --msgbox "Signing client failed. Please sign and force to deply config later" 5 40
			sign_response=1
		fi

		# prepare host config
		echo 50 | dialog --backtitle "Client Management" --gauge "Create default config ..." 7 70 0
	    	mkdir -p $CLIENTHOME/$hostid 
	    	cp -ar /etc/yasa/skell/{etc,temp} $CLIENTHOME/$hostid
		host_write_rule $hostid
		
		echo 70 | dialog --backtitle "Client Management" --gauge "Add client to puppet site.pp ..." 7 70 0
		host_add_puppet $hostid

		echo 80 | dialog --backtitle "Client Management" --gauge "Deploy config to client ..." 7 70 0
		[ "$sign_resonse" != "1" ] && host_deploy_config $hostid 
		break
	    fi
	done

	# echo added successfully
	dialog --backtitle "Client Management" --title "Add Host" --msgbox "$hostid added successfully" 6 40
	
	log_main 100 $hostid - - - The $hostid added successfully

	return 0
}

host_del() {
	## This function deactive yasa on client and remove its config from
	## Yasa configuration manager. If cant disable client remove have been
	## failed

	local hostid
	local response
	local output=$(mktemp /tmp/output.XXXXXXX) 
	
	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

        # list all hosts      
        dialog --backtitle "Client Management" --title " Clients List " --menu "Choose a hostname to delete from Yasa" 11 60 10 $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $output 
        
	# get response
	response=$?
	
        # if user press cancel, escape 
	if [ "$response" == "1" -o "$response" == "255" -o -z "$(<$output)" ]
        then 
                # remove temp file             
                [ -f "$output" ] && rm $output

                return 1
        fi

	# get hostname
	hostid=$(<$output)

	# confirmation
        dialog --backtitle "Client Management"  --title " Warning " --yesno "Do you realy want delete the host?" 6 50

	# get response
	response=$?
	
        # if user press cancel or escape
	if [ "$response" == "1" -o "$response" == "255" ]
        then
                 # remove temp file
                 [ -f "$output" ] && rm $output

                 return 1
        fi

	# first disable yasa
	host_disable_yasa $hostid

	# get response
	response=$?

	# if disable yasa failed stop.
	if [ "$response" == "2" ]
	then
		return 1
	elif [ "$response" != "0" ]
	then
		dialog --backtitle "Client Management" --msgbox "Disabling $hostid, failed. Host not deleted from Yasa" 5 70
		
		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi

	# deploy config with configuration management
	host_deploy_config $hostid silent
	
	# get response
	response=$?

	if [ "$response" != "0" ]
	then
		 dialog --backtitle "Client Management" --msgbox "Disabling $hostid, failed. Host not deleted from Yasa" 5 70
		# remove temp file
		[ -f "$output" ] && rm $output
	
		return 1
	fi
	
	# remove host folder from configurations
        rm -r $CLIENTHOME/$hostid

        dialog --backtitle "Client Management" --msgbox "The host deleted successfuly." 5 40

	log_main 101 $hostid - - - The $hostid deleted successfully

	# remove temp file
	[ -f "$output" ] && rm $output
	
	return 0
}

host_modify() {
	## Modify host rule
	
	# lacal variables
	local hostid
	local response
	local output=$(mktemp /tmp/output.XXXXXXX) 
	
	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

        # list all hosts      
        dialog --backtitle "Client Management" --title " Clients List " --menu "Choose a hostname to delete from Yasa" 11 60 10 $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $output 
        
	# get response
	response=$?
	
        # if user press cancel, escape 
	if [ "$response" == "1" -o "$response" == "255" -o -z "$(<$output)" ]
        then 
                # remove temp file             
                [ -f "$output" ] && rm $output

                return 1
        fi

	# get hostname
	hostid=$(<$output)

	# check that not in any group
	host_is_it_member $hostid

	# get response                 
	response=$?                    
	
	if [ "$response" == "0" ]      
	then                           
	        groupid=$(host_is_it_member $hostid)
	        dialog --backtitle "Client Management" --msgbox "$hostid is memeber of \"$groupid\" group\nPlease modify group for make change in whitelist" 7 55   
	
	        # remove temp file if exist    
	        [ -f "$output" ] && rm $output
	
	        return 1                       
	
	fi   

	# loop for modify host rule (add and remove class, add device, del device)
	while true
	do
		# select what you want
		dialog --backtitle "Client Management" --title "[ H O S T - M O D I F Y ]" \
		--menu "Choose what you want to do.\n\
		Press cancel to exit from this menu.\n\
		Notice: After edit class and device list run \"Deploy Config Change\"" 16 70 5 \
		1 "Add/Remove Class" \
		2 "Add Device" \
		3 "Delete Device" \
		4 "Deploy Config Changes" \
	        Exit "Return to Main Menu" 2>"${output}"
	
		# get response
		response=$?

		# if user enter cancel or press esc
		if [ "$response" == "1" -o "$response" == "255" ]
		then
		        # remove temp file
		        [ -f "$output" ] && rm $output

			return 0
		fi

	        # make decision
	        case $(<$output) in
			1) modify_class host $hostid;;
			2) modify_add_dev host $hostid;;
			3) modify_del_dev host $hostid;;
	                4) host_deploy_config $hostid;;
	                Exit) echo "Bye"; break;;
	        esac
	done

	# remove temp file
	[ -f "$output" ] && rm $output

	return 0
}

host_en_dis() {
	## This function use for enable and disable yasa on client

	# lacal variables
	local hostid
	local response
	local output=$(mktemp /tmp/output.XXXXXXX) 
	
	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

        dialog --backtitle "Client Management" --title " Clients List" --menu "Choose a hostname to delete from Yasa" 11 60 10 $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} " | tr -d "\n"; done) 2> $output 
 
	# get response
	response=$?
	
        # if user press cancel, escape 
	if [ "$response" == "1" -o "$response" == "255" -o -z "$(<$output)" ]
        then 
                # remove temp file             
                [ -f "$output" ] && rm $output

                return 1
        fi

	# get hostname
	hostid=$(<$output)

	# check that not in any group
	host_is_it_member $hostid

	# get response                 
	response=$?                    
	
	if [ "$response" == "0" ]      
	then                           
	        groupid=$(host_is_it_member $hostid)
	        dialog --backtitle "Client Management" --msgbox "$hostid is memeber of \"$groupid\" group\nPlease remove it from group befor change." 7 55   
	
	        # remove temp file if exist    
	        [ -f "$output" ] && rm $output
	
	        return 1                       
	
	fi   

	# main part of function to call enable/disable function
	if [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "0" ]
	then
		host_disable_yasa $hostid
		dialog --backtitle "Client Management" --msgbox "USB Restrictions Deactivated" 5 40

		log_main 103 $hostid - - - The $hostid disabled.

	elif [ "$(cat $CLIENTHOME/$hostid/temp/$WDEF)" == "1" ] 
	then
		host_enable_yasa $hostid
		dialog --backtitle "Client Management" --msgbox "USB Restrictions Activated" 5 40
		log_main 102 $hostid - - - The $hostid enabled.
	fi
	
	host_deploy_config $hostid

	# remove temp file if exist    
	[ -f "$output" ] && rm $output
	
	return 0
}

host_force_update() {
	# temperorly file 
        output=$(mktemp /tmp/usb.XXXXXXXX)
	failedhost=$(mktemp /tmp/usb.XXXXXXXX)

        # trap and delete temp file
        trap "rm $output; exit" SIGHUP SIGINT SIGTERM
        trap "rm $failedhost; exit" SIGHUP SIGINT SIGTERM

	# local variables
	local hostid
	local response
	local hostsum

	hostsum=$(ls $CLIENHOME | wc -l)

	dialog --title "Choose host(s)" --checklist "Choose one/more/all host(s) to update whitelist" 10 60 $hostsum all hosts off $(for i in $CLIENTHOME/*; do j=${i##*/}; echo "$j ${j%%.*} off " | tr -d "\n"; done) 2> $output
	
	# get response
	response=$?

	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$output" ] && rm $output
		[ -f "$failedhost" ] && rm $failedhost
		return 1
	fi

	if [ -z "$(<$output)" ]
	then
		[ -f "$output" ] && rm $output
		[ -f "$failedhost" ] && rm $failedhost
		return 1
	fi

	for hostid in $(<$output)	
	do
	    if [ "$hostid" == all ]
	    then
		for hostid in $(ls $CLIENTHOME)
		do
		    host_write_rule $hostid
		    host_deploy_config $hostid silent >> $failedhost		
		done
		break
	    fi
	    host_write_rule $hostid
	    host_deploy_config $hostid silent >> $failedhost		
	done

	if [ -z "$(<$failedhost)" ]
	then
		echo "Client configuration deployment Process successfuly done." > $failedhost
		dialog --backtitle "Yasa Management" --title "Client Deployment" --textbox $failedhost 10 80
	else
		dialog --backtitle "Yasa Management" --title "Failed Host(s)" --textbox $failedhost 10 80
	fi

	# remove temp file
	[ -f "$output" ] && rm $output
	[ -f "$failedhost" ] && rm $failedhost

	return 0

}

report_add_remove_hosts() {
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# filter logs
	cat $YASA_ADMIN_LOG | awk '($3 == 100) || ($3 == 101 ) || ($3 == 102 ) || ($3 == 103 )' | tail -100 > $output
	# local variable
	dialog --backtitle "Client Management" --title "R E P O R T - C L I E N T S" --textbox $output 14 75

	# remove temp file if exist    
	[ -f "$output" ] && rm $output

	return 0
}

report_add_remove_groups() {
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# filter logs
	cat $YASA_ADMIN_LOG | awk '($3 == 200) || ($3 == 201 )' | tail -100 > $output
	# local variable
	dialog --backtitle "Client Management" --title "R E P O R T - G R O U P S" --textbox $output 14 75

	# remove temp file if exist    
	[ -f "$output" ] && rm $output

	return 0
}

report_deploy_config() {
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# filter logs
	cat $YASA_ADMIN_LOG | awk '($3 == 104) || ($3 == 105 ) || ($3 == 106 ) || ($3 == 107 )' | tail -100 > $output
	# local variable
	dialog --backtitle "Client Management" --title "R E P O R T - D E P L O Y M E N T S" --textbox $output 14 75

	# remove temp file if exist    
	[ -f "$output" ] && rm $output

	return 0
}


report_custom_search() {
	# temp file for dialog output
	local output=$(mktemp /tmp/usb.XXXXXXX)

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM

	# search based on ip address
	dialog --backtitle "$backtitle" --inputbox "Please search the keywork to filter logs" 8 80 2> $output

	# save dialog state (find if user press cancel)
	response=$?

	# save input variable
	keyword=$(<$output)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then
		[ -f "$output" ] && rm $output
	
		return 1
	fi

	# normalize log file
	cat $YASA_ADMIN_LOG | grep -i "$keyword" | tail -100  > "$output"

	if [ -z "$(<$output)" ]
	then
	    echo "Failed! Try another keyword" > $output
	fi

	dialog --backtitle "Client Management" --title "R E P O R T - C U S T O M S E A R C H" --textbox $output 14 75

	# remove temp file if exist    
	[ -f "$output" ] && rm $output

	return 0
}

deploy_yasaclient() {
	# local variables
	local output=$(mktemp /tmp/usb.XXXXXXX)
	local hostid
	local hostname
	local response
	local package_name
	local distro
	local server_name=$(hostname -f)
	local sshport
	local sshcmd
	local scpcmd

	# trap and delete temp file
	trap "rm $output; exit" SIGHUP SIGINT SIGTERM


	# check ssh key exist in KEYSDIR
	if [ ! -f "$KEYSDIR/server" -a ! -f "$KEYSDIR/server.pub" ]
	then
		dialog --backtitle "Install Wizard" --title "Error Message" --msgbox "SSH keys doesnt exist. Please create and deploy keys from main menu." 6 60

		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi

	# get hostname from admin
	dialog --backtitle "Install Wizard" --title "I N P U T B O X" --inputbox "Please enter valid hostname." 8 70 2>"$output"

	# get reponse
	response=$?

	# get hostid
	hostid=$(<$output)

	# if user cancel the dialog or press escape 
	if [ "$response" == "1" -o "$response" == "255" ]
	then 
		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi
	
	# hostid validation
	if [ -z "$(echo "$hostid" | egrep "^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][a-zA-Z0-9_-]{1,61}[a-zA-Z0-9]))\.([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,})$")" ] 
	then
		dialog --backtitle "Install Wizard" --title "Error Message" --msgbox "Entered hostname is invalid, please use valid format" 6 60
		
		# remove temp file if exist    
		[ -f "$output" ] && rm $output

		return 1
	fi

	# check hostname is reachable
	ping -c 1 $hostid > /dev/null 2>&1

	# get response
	response=$?

	if [ "$response" != "0" ]
	then
		dialog --backtitle "Install Wizard" --title "Error Message" --msgbox "Client not accessable please check your network connectivity and try again." 6 60

		# remove temp file
		[ -f "$output" ] && rm $output
		
		return 1
	fi

	# ssh port number
	dialog --backtitle "Install Wizard" --title " SSH Port " --inputbox "Enter SSH port number on client" 6 70 22 2>$output

	sshport=$(<$output)

	# copy yasaclient from /usr/share/lib/yasa. befor it, find package name
	package_name=$(ls /usr/share/lib/yasa/yasaclient*)
	package_name=${package_name##*/}

	# choose linux distribution for install dependencies
	dialog --backtitle "Install Wizard" --title " Choose Distros " --menu "Plaes linux distributin that install on client target." 11 60 11 \
	"Jessie" "Debian 8.7" \
	"Xenial" "Ubuntu 16.04 LTS" \
	"Trusy" "Ubuntu 14.04 LTS" 2> $output
	
	# get response
	response=$?

	# if user enter cancel or press esc
	if [ "$response" == "1" -o "$response" == "255" ]
	then
	        # remove temp file
	        [ -f "$output" ] && rm $output

		return 1
	fi

	distro=$(<$output)
	distro=${distro,,}

	if [ -z "$sshport" ]
	then
	    sshcmd="ssh -oStrictHostKeyChecking=no -i $KEYSDIR/server"
	    scpcmd="scp -oStrictHostKeyChecking=no -i $KEYSDIR/server"
	else
	    sshcmd="ssh -p $sshport -oStrictHostKeyChecking=no -i $KEYSDIR/server"
	    scpcmd="scp -P $sshport -oStrictHostKeyChecking=no -i $KEYSDIR/server"
	fi

	# check client hostname config correctly
	hostname=$($sshcmd root@$hostid "hostname -f")

	if [ "$hostid" != "$hostname" ]
	then
	    dialog --backtitle "Install Wizard "  --title " Hostname Configuratoin " --msgbox "Real hostname is different from what you entered. Please config client hostname correctly based on these step and try again:\n\
		1- Edit /etc/hostname\n\
		somthing.example.com\n\
		2- Run \"hostname -F /etc/hostname\"\n\
		3- edit /etc/hosts\n\
		192.168.1.10	somthing.example.com somthing" 12 70

	    	return 1
	fi

	# copy packages based on distribution
	$scpcmd -r /usr/share/lib/yasa/$distro root@$hostid:/tmp/debs
	if [ "$?" != "0" ] 
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Installation failed in while copying packages." 6 70
	    
	    [ -f "$output" ] && rm $output
	    return 1
	fi

	$scpcmd /usr/share/lib/yasa/$package_name root@$hostid:/tmp/
	if [ "$?" != "0" ] 
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Installation failed in while copying packages." 6 70
	    [ -f "$output" ] && rm $output
	    return 1
	fi

	# dpkg -i yasaclient with all dependencies or done with apt-get
	$sshcmd root@$hostid "DEBIAN_FRONTEND=noninteractive dpkg -i /tmp/debs/{libpython2.7-minimal*,python2.7-minimal*.deb,python-minimal*}"
	if [ "$?" != "0" ]
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Installation of predepend packages failed." 6 70
	    [ -f "$output" ] && rm $output
	    return 2
	fi

	$sshcmd root@$hostid "DEBIAN_FRONTEND=noninteractive dpkg -i /tmp/debs/*.deb"
	if [ "$?" != "0" ]
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Installation of dependency packages failed." 6 70
	    [ -f "$output" ] && rm $output
	    return 3
	fi

	# set yasaclient answer on client
	$sshcmd root@$hostid "echo \"yasaclient yasaclient/hostname string $hostid\" | debconf-set-selections ; echo \"yasaclient yasaclient/server_name string $server_name\" | debconf-set-selections"
	if [ "$?" != "0" ] 
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Configuration of yasaclient package failed." 6 70
	    [ -f "$output" ] && rm $output
	    return 4
	fi

	$sshcmd root@$hostid "dpkg -i /tmp/$package_name"
	if [ "$?" != "0" ] 
	then 
	    dialog --backtitle "Install Wizard "  --title " Installation Failed " --msgbox "Installtion of yasaclient package failed." 6 70
	    [ -f "$output" ] && rm $output
	    
	    return 4
	fi
	
	# remove temp file if exist    
	[ -f "$output" ] && rm $output

	return 0
}

yasa_rsyslog_config() {
    ## add rsyslog config and restart it to readey for yasa
    # local variables


    
    return 0    
}

server_preparation() {
	# local variables	
	local output=$(mktemp /tmp/usb.XXXXXXXX)

	# check dependencies

	# check site.pp config

	# rsyslog config for yasa
	server_sync_host_puppet

	server_all_host_sign

	
}

generate_new_ssh_keys() {
    # local variables
    local response

    # check if previus key exist
    if [ -f "/etc/yasa/keys/server" -o -f "/etc/yasa/keys/server.pub" ]
    then
        dialog --backtitle "Generate SSH Keys"  --title " Keys Exists " --yesno "SSH keys exists. Are you sure delete old keys and create new one?" 6 50
        
        # get response
        response=$?
        
        # if user press cancel or escape
        if [ "$response" == "1" -o "$response" == "255" ]
        then
            # remove temp file
            [ -f "$output" ] && rm $output

            return 1
	else
	    rm -r /etc/yasa/keys/server*	 
        fi
    fi

    # generate new keys
    ssh-keygen -f /etc/yasa/keys/server -N ''

    # find successfull creation
    response=$?

    if [ "$response" == "0" ]
    then
	dialog --backtitle "Generate SSH Keys"  --title " Successfull " --msgbox "SSH keys generated successfuly. You can find it in \"/etc/yasa/keys\"." 6 65
    else
	dialog --backtitle "Generate SSH Keys"  --title " Failed " --msgbox "SSH keys generation faild. Find the error and retry again." 6 65
	return 1
    fi

    return 0
}

yasa_cron() {
        # temperorly file 
        TEMP=$(mktemp /tmp/usb.XXXXXXXX)

        # trap and delete temp file
        trap "rm $TEMP; exit" SIGHUP SIGINT SIGTERM

	# save current time
	local currenttime=$(date +"%s")

	# variable for save dev.allow line
	local scomment
	local ucomment
	local line

	# remove dev allow rule based on expire time
	for host_dir in "$CLIENTHOME/*"
	do
		if [ -d "$host_dir" ]
		then
			while read line
			do
				if [ ! -z "$(echo $line | grep "^# comment")" ]
				then
					ucomment=$line
				elif [ ! -z "$(echo $line | grep "^# From:")" ]
				then
					scomment=$line
				elif [ ! -z "$(echo $line | grep "^[0-9]" )" ]
				then
					if [ ! -z "$(echo $line  | awk '($1 > value ) ' value=$currenttime)" -o "$(echo $line | awk '{ print ( $1 ) }')" == "0" ]
					then
						echo -e "$ucomment\n$scomment\n$line" >> $TEMP
					fi
				else
					echo $line >> $TEMP
				fi
			done < $host_dir/temp/$WDEVICE
			cp $TEMP $host_dir/temp/$WDEVICE
		else
			continue
		fi

		# write rule for each
		host_write_rule $hostid

		# deploy rule for each host
		host_deploy_config $hostid
	done

	# remove class based on expire time
	# not implemented

	# remove temp file
	[ -f "$TEMP" ] && rm $TEMP

}

yasa_auth() {
	local name=/sys$1
	local value=$2
	echo "$value" > "${name%/*}/authorized" 2>> /dev/null
	echo "${name%/*}/authorized" >> /var/log/yasa-auth.log
	return 0
}


# Non-interactive mod
if [ ! -z "$1" ]
then
	if [ "$1" = "cron" ]
	then
		yasa_cron
	elif [ "$1" = "auth" ]
	then
		yasa_auth $2 $3
	elif [ "$1" == "web" ]
	then
		[ -z "$2" ] && exit 1
		case "$2" in
			1) echo "N" ;;
		esac
	fi

# Interactive mod
else
	check_prerequire_config
	
	# get response
	response=$?

	if [ "$response" != "0" ]
	then
		exit 1
	fi

	main_menu
fi

exit 0
